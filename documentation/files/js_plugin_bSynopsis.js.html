<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>js/plugin/bSynopsis.js - bSynopsis</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="bSynopsis"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/bSynopsis_GLOBAL.html">bSynopsis_GLOBAL</a></li>
            
                <li><a href="../classes/bSynopsis_GLOBAL_UTIL.html">bSynopsis_GLOBAL_UTIL</a></li>
            
                <li><a href="../classes/bSynopsis_JQuery_Custom.html">bSynopsis_JQuery_Custom</a></li>
            
                <li><a href="../classes/Cache.html">Cache</a></li>
            
                <li><a href="../classes/Plugin.html">Plugin</a></li>
            
                <li><a href="../classes/Plugin.ComponentFactory.html">Plugin.ComponentFactory</a></li>
            
                <li><a href="../classes/Plugin.EventManager.html">Plugin.EventManager</a></li>
            
                <li><a href="../classes/Plugin.Layer.html">Plugin.Layer</a></li>
            
                <li><a href="../classes/Plugin.Layers.Blank.html">Plugin.Layers.Blank</a></li>
            
                <li><a href="../classes/Plugin.Layers.Inlay.html">Plugin.Layers.Inlay</a></li>
            
                <li><a href="../classes/Plugin.Layers.Literal.html">Plugin.Layers.Literal</a></li>
            
                <li><a href="../classes/Plugin.Layers.Res.html">Plugin.Layers.Res</a></li>
            
                <li><a href="../classes/Plugin.LayoutEngine.html">Plugin.LayoutEngine</a></li>
            
                <li><a href="../classes/Plugin.Node.html">Plugin.Node</a></li>
            
                <li><a href="../classes/Plugin.NodeFactory.html">Plugin.NodeFactory</a></li>
            
                <li><a href="../classes/Plugin.Nodes.Blank.html">Plugin.Nodes.Blank</a></li>
            
                <li><a href="../classes/Plugin.Nodes.Literal.html">Plugin.Nodes.Literal</a></li>
            
                <li><a href="../classes/Plugin.Nodes.Res.html">Plugin.Nodes.Res</a></li>
            
                <li><a href="../classes/Plugin.RdfStore.html">Plugin.RdfStore</a></li>
            
                <li><a href="../classes/Plugin.RemoteDataLoader.html">Plugin.RemoteDataLoader</a></li>
            
                <li><a href="../classes/Plugin.TemplatesLoader.html">Plugin.TemplatesLoader</a></li>
            
                <li><a href="../classes/Plugin.TimeLine.html">Plugin.TimeLine</a></li>
            
                <li><a href="../classes/Plugin.TimeLine.Node.html">Plugin.TimeLine.Node</a></li>
            
                <li><a href="../classes/RemoteEngine.html">RemoteEngine</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/bSynopsis.html">bSynopsis</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js/plugin/bSynopsis.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * bSynopsis is a JQuery Plugin for RDF visualization.
 * 
 * @module bSynopsis
 * @main Plugin
 * @param {} $
 * @param {}
 *           window
 * @param {}
 *           document
 * @param {}
 *           undefined
 */

// safety net for unclosed plugins and/or chained functions
;
(function($, window, document, undefined) {

	// get global vars
	var $window = $(window);

	// ========================= bSynopsis Constants
	// ===============================
	var CONS = {
		// Part of CSS class to indicate a filterable
		FA_TAG : &quot;synopsis_filter_&quot;,
		// Part of CSS class to indicate a token
		TOKEN_TAG : &quot;synopsis_token_&quot;,
		NODE_TYPES : {
			stdNode : &quot;stdNode&quot;,
			literal : &quot;literal&quot;,
			blankNode : &quot;blankNode&quot;,
			resNode : &quot;resNode&quot;
		},
		COMP_TYPES : {
			predicate : &quot;predicate&quot;,
			label : &quot;label&quot;,
			uri : &quot;uri&quot;
		},
		CSS_PREFIX : &quot;synopsis_&quot;,

		// CSS classes to use
		CSS_CLASSES : {
			outerContainer : &quot;outerContainer&quot;,
			viewContainer : &quot;container&quot;,
			options : &quot;options&quot;,
			optionCombo : &quot;option-combo&quot;,
			optionSet : &quot;option-set&quot;,
			optionButton : &quot;option-button&quot;,
			groupLabel : &quot;groupLabel&quot;,
			filter : &quot;filter&quot;,
			clearfix : &quot;clearfix&quot;,
			loader : &quot;loading&quot;,
			preview : &quot;preview&quot;,
			previewItem : &quot;preview-item&quot;,
			previewContent : &quot;previewContent&quot;,
			overlay : &quot;overlay&quot;,
			overlayContent : &quot;overlayContent&quot;,
			refresh : &quot;refresh&quot;,
			innerScroll : &quot;innerScroll&quot;,
			innerNoScroll : &quot;innerNoScroll&quot;,
			buttonClose : &quot;close&quot;,
			timelineContainer : &quot;timelineContainer&quot;,
			timeline : &quot;timeline&quot;,
			buttonTimeline : &quot;btnTimeline&quot;,
			sorter : &quot;sorter&quot;,
			textScale : &quot;textScale&quot;,
			textScaleDone : &quot;textScaleDone&quot;,
			tileClasses : {
				tile : &quot;tile&quot;,
				content : &quot;tileContent&quot;,
				label : &quot;label&quot;,
				showURI : &quot;showURI&quot;,
				predicate : &quot;predicate&quot;,
				predicateLabel : &quot;predicateLabel&quot;,
				typeImage : &quot;typeImage&quot;,
				number : &quot;number&quot;
			},
			typeClasses : {
				incoming : &quot;incoming&quot;,
				outgoing : &quot;outgoing&quot;
			},
			patternClasses : {
				uri : &quot;uri&quot;,
				literal : &quot;literal&quot;,
				blanknode : &quot;blank&quot;
			}
		},
		// Placeholder in query strings
		DUMMY : &quot;#replaceMe#&quot;,
		// Event types for Pub/Sub system
		EVENT_TYPES : {
			store : {
				insert : &quot;dataInsert&quot;
			},
			loading : {
				done : &quot;loadingDone&quot;,
				start : &quot;loadingStarted&quot;
			},
			layout : {
				done : &quot;layoutingDone&quot;
			}
		},
		MESSAGES : {
			out : {
				selectAllFilters : &quot;Select All&quot;
			},
			error : {
				ajax : &quot;Error on loading data.&quot;,
				remote : &quot;Error on loading remote data.&quot;,
				template : &quot;Error on loading template data.&quot;,
				tokenType : &quot;Unknown token type of item.&quot;,
				compType : &quot;Unknown component type of item.&quot;
			},
			warn : {
				cssAppend : &quot;CSS classes already defined&quot;,
				fileTypeNotKnown : &quot;Couldn&#x27;t get filetype. Using: &quot;,
				filterInput : &quot;Filterinput is empty&quot;,
				filterName : &quot;Filtername duplicate found&quot;
			}
		}
	};

	var UTIL = {
		toClass : function(str) {
			return CONS.CSS_PREFIX + str;
		},
		toToken : function(str) {
			return CONS.TOKEN_TAG + str;
		},
		toFilterable : function(str) {
			return CONS.FA_TAG + str;
		},
		toClassSelector : function(str) {
			return &quot;.&quot; + CONS.CSS_PREFIX + str;
		},
		toSelector : function(str) {
			return &quot;.&quot; + str;
		}
	};

	// Add prefix to given objects strings
	function objPrefixer(prefix, obj) {
		$.each(obj, function(i, val) {
			if (typeof val === &quot;string&quot;) {
				obj[i] = prefix + val;
			} else {
				objPrefixer(prefix, val);
			}
		});
	}

	// Add css_prefix to css_classes
	objPrefixer(CONS.CSS_PREFIX, CONS.CSS_CLASSES);

	// ========================= Extend Isotope ===============================
	// Extend Isotope - groupRows custom layout mode
	// Modified Version of
	// http://isotope.metafizzy.co/custom-layout-modes/category-rows.html
	// $
	// .extend(
	// $.Isotope.prototype,
	// {
	// _groupRowsReset : function() {
	// this.groupRows = {
	// x : 0,
	// y : 0,
	// gutter : 0,
	// height : 0,
	// currentGroup : null
	// };
	// },
	// _groupRowsLayout : function($elems) {
	// var instance = this, containerWidth = this.element.width(), sortBy =
	// this.options.sortBy, props = this.groupRows;
	//
	// $elems
	// .each(function() {
	// var $this = $(this), atomW = $this.outerWidth(true), atomH = $this
	// .outerHeight(true), group = $.data(this, &#x27;isotope-sort-data&#x27;)[sortBy];
	//
	// if (group !== props.currentGroup) {
	// // new group, new row
	// props.x = 0;
	// props.height += props.currentGroup ? instance.groupRows.gutter : 0;
	// props.y = props.height;
	// props.currentGroup = group;
	//
	// if (instance.groupRows.gutter &lt; atomH) {
	// instance.groupRows.gutter = atomH;
	// }
	//
	// } else {
	//
	// if (props.x !== 0 &amp;&amp; atomW + props.x &gt; containerWidth) {
	//
	// // if this item cannot fit in
	// // the current row
	// props.x = 0;
	// props.y = props.height;
	// }
	// }
	//
	// $this.find(UTIL.toSelector(CONS.CSS_CLASSES.groupLabel)).remove();
	// // label for new group
	// if (group !== &#x27;&#x27;) {
	// var prefix = group.split(&quot;_&quot;)[0] + &quot;_&quot;;
	// var groups = group.split(prefix), divBox = &quot;&lt;div class=&#x27;&quot;
	// + CONS.CSS_CLASSES.groupLabel + &quot;&#x27; &gt;&quot;;
	// for (var i = 1; i &lt; groups.length; i++) {
	// divBox += groups[i];
	// }
	// divBox += &quot;&lt;/div&gt;&quot;;
	// $this.append(divBox);
	// }
	//
	// // position the atom
	// instance._pushPosition($this, props.x, props.y);
	//
	// props.height = Math.max(props.y + atomH, props.height);
	// props.x += atomW;
	// });
	// },
	// _groupRowsGetContainerSize : function() {
	// return {
	// height : this.groupRows.height
	// };
	// },
	// _groupRowsResizeChanged : function() {
	// return true;
	// }
	//
	// });

	// ========================= JQuery custom selectors
	/**
	 * class JQuery custom selectors
	 * 
	 * @class bSynopsis_JQuery_Custom
	 */

	/**
	 * JQuery custom class prefix selector.
	 * 
	 * @method class-prefix
	 * @param {}
	 *           ele
	 * @param {}
	 *           index
	 * @param {}
	 *           match
	 */
	$.expr[&#x27;:&#x27;][&#x27;class-prefix&#x27;] = function(ele, index, match) {
		var prefix = match[3];

		if (prefix) {
			var sel = &#x27;[class^=&quot;&#x27; + prefix + &#x27;&quot;], [class*=&quot; &#x27; + prefix + &#x27;&quot;]&#x27;;
			return $(ele).is(sel);
		} else {
			return true;
		}
	};

	/**
	 * JQuery custom regex selector. (modified the version of James Padolsey -
	 * http://james.padolsey.com/javascript/regex-selector-for-jquery/)
	 * 
	 * @method regex
	 * @param {}
	 *           elem
	 * @param {}
	 *           index
	 * @param {}
	 *           match
	 */
	$.expr[&#x27;:&#x27;].regex = function(elem, index, match) {
		var matchParams = match[3].split(&#x27;,&#x27;), validLabels = /^(data|css):/, attr = {
			method : matchParams[0].match(validLabels) ? matchParams[0].split(&#x27;:&#x27;)[0] : &#x27;attr&#x27;,
			property : matchParams.shift().replace(validLabels, &#x27;&#x27;)
		}, regexFlags = &#x27;ig&#x27;, regex;
		try {
			regex = new RegExp(matchParams.join(&#x27;&#x27;).replace(/^\s+|\s+$/g, &#x27;&#x27;), regexFlags);
		} catch (e) {
			return false;
		}
		return regex.test(jQuery(elem)[attr.method](attr.property));
	};

	// ========================= JQuery textfill
	// https://gist.github.com/mekwall/1263939 by Marcus Ekwall
	// Additions by Thomas Wei√ügerber
	(function($) {
		$.fn.textfill = function(maxFontSize, minFontSize, fail) {
			maxFontSize = parseInt(maxFontSize, 10);
			minFontSize = parseInt(minFontSize, 10);
			return this
					.each(function(i, val) {
						var ourText = $(val), parent = ourText.parent(), maxHeight = parent.height(), maxWidth = parent
								.width(), fontSize = parseInt(ourText.css(&quot;fontSize&quot;), 10), tmpMultW = maxWidth
								/ ourText.width(), tmpMultH = maxHeight / ourText.height(), multiplier = (tmpMultW &lt; tmpMultH) ? tmpMultW
								: tmpMultH, newSize = (fontSize * (multiplier - 0.1));
						if (maxFontSize &gt; 0 &amp;&amp; newSize &gt; maxFontSize) {
							newSize = maxFontSize;
						}
						if (minFontSize &gt; 0 &amp;&amp; newSize &lt; minFontSize) {
							newSize = minFontSize;
							fail(parent);
						}
						ourText.css(&quot;fontSize&quot;, newSize);
					});
		};
	})(jQuery);

	// ========================= bSynopsis class private utility functions
	/**
	 * class private utility functions
	 * 
	 * @class bSynopsis_GLOBAL_UTIL
	 */

	/**
	 * Checks if given variable is undenfined or null.
	 * 
	 * @method isUndefinedOrNull
	 * @param {Object}
	 *           a Variable to check
	 * @return {Boolean} Returns true on success
	 */
	function isUndefinedOrNull(a) {
		return ((typeof a === &quot;undefined&quot;) || (a === null));
	}

	function construct(constructor, args) {
		function F() {
			return constructor.apply(this, args);
		}
		F.prototype = constructor.prototype;
		return new F();
	}

	// Only print to console, if DEBUG mode is enabled
	var print = console.log.bind(console);
	function appendCssClasses(obj) {
		if (obj) {
			if (!obj.CSS_CLASSES) {
				obj.CSS_CLASSES = CONS.CSS_CLASSES;
			} else {
				console.log(CONS.MESSAGES.warn.cssAppend);
			}
		}
		return obj;
	}

	/**
	 * Replace the DUMMY constants of given query with the given
	 * replacementstring.
	 * 
	 * @method replaceDummy
	 * @param {String}
	 *           query Query to work with
	 * @param {String}
	 *           replacement String to replace the CONS.DUMMY of given query
	 * @return {String} Returns the query with replaced DUMMY constants
	 */
	function replaceDummy(query, replacement) {
		return query.replace(new RegExp(CONS.DUMMY, &quot;g&quot;), replacement);
	}

	/**
	 * Gets the current window size of the browser.
	 * 
	 * @method getWindowSize
	 * @param {Boolean}
	 *           withoutScrollbar Flag to assign if the scrollbar should be
	 *           considered
	 * @return {Object} Object which contains the width and the height of the
	 *         window.
	 */
	function getWindowSize(withoutScrollbar) {
		var w = null, h = null;
		if (withoutScrollbar) {
			if ($(&#x27;BODY&#x27;).hasClass(&#x27;noscroll&#x27;)) {
				w = $window.width(), h = $window.height();
			} else {
				$(&#x27;BODY&#x27;).addClass(&#x27;noscroll&#x27;);
				w = $window.width(), h = $window.height();
				$(&#x27;BODY&#x27;).removeClass(&#x27;noscroll&#x27;);
			}
		} else {
			w = $window.width(), h = $window.height();
		}
		return {
			width : w,
			height : h
		};
	}

	/**
	 * Gets the clip data of given type of div box
	 * 
	 * @method getClip
	 * @param {String}
	 *           name CSS name as defined in CONS.CSS_CLASSES of given div box
	 * @return {Object} Rectangle Object / Clip data
	 */
	function getClip(name) {
		var winsize;
		switch (name) {
		case CONS.CSS_CLASSES.overlay:
			winsize = getWindowSize(true);
			return &#x27;rect(0px &#x27; + winsize.width + &#x27;px &#x27; + winsize.height + &#x27;px 0px)&#x27;;
			break;
		case CONS.CSS_CLASSES.preview:
			winsize = getWindowSize(false);
			return &#x27;rect(&#x27; + winsize.height * 0.25 + &#x27;px &#x27; + winsize.width * 0.75 + &#x27;px &#x27; + winsize.height
					* 0.75 + &#x27;px &#x27; + winsize.width * 0.25 + &#x27;px)&#x27;;
			break;
		default:
			console.log(&quot;No clip data found.&quot;);
			return &quot;&quot;;
		}
	}

	/**
	 * Gets the layoutprop of given item
	 * 
	 * @method getItemLayoutProp
	 * @param {$item}
	 *           $item JQuery item
	 * @return {Object} Object which contains the layoutprops
	 */
	function getItemLayoutProp($item) {
		var scrollT = $window.scrollTop(), scrollL = $window.scrollLeft(), itemOffset = $item.offset();
		return {
			left : itemOffset.left - scrollL,
			top : itemOffset.top - scrollT,
			width : $item.outerWidth(),
			height : $item.outerHeight()
		};
	}

	/**
	 * Get browser dependent event names. (Uses Modernizr)
	 * 
	 * @method getTransEndEventName
	 * @return {String} TransitionEnd event name of the current browser
	 */
	function getTransEndEventName() {
		var transEndEventNames = {
			&#x27;WebkitTransition&#x27; : &#x27;webkitTransitionEnd&#x27;,
			&#x27;MozTransition&#x27; : &#x27;transitionend&#x27;,
			&#x27;OTransition&#x27; : &#x27;oTransitionEnd&#x27;,
			&#x27;msTransition&#x27; : &#x27;MSTransitionEnd&#x27;,
			&#x27;transition&#x27; : &#x27;transitionend&#x27;
		};
		// transition end event name
		return transEndEventNames[Modernizr.prefixed(&#x27;transition&#x27;)];
	}

	// ========================= bSynopsis: RemoteEngine Class
	/**
	 * Class to provide a function for SPARQL querying of the service located at
	 * the given url. YQL is used to fetch the queryresults.
	 * 
	 * @class RemoteEngine
	 * @constructor
	 */
	var RemoteEngine = function() {

		// TODO YQL timeout??

		var counter = 0;

		// This function uses YQL to give a SPARQL query to a remote service.
		// Accepts a query, the adress of the service and a callback function to
		// run.
		this._corsRequestSPARQL = function(query, url, callback) {

			var that = this, success = false, cnt = counter++;

			// Use cnt to stop callbackoverwriting on simultan calls
			window[&quot;cbFunc&quot; + cnt] = function(data, textStatus, jqXHR) {
				// If we have something to work with...
				if (data &amp;&amp; data.results &amp;&amp; data.results.bindings) {
					success = true;
					callback(data.results.bindings, success);
				}

				// Else, Maybe we requested a site that doesn&#x27;t exist, and
				// nothing returned.
				else {
					console.log(&#x27;Nothing returned from getJSON.&#x27;);
					callback(null, success);

					// Delete old callbackfunction
					window[&quot;cbFunc&quot; + cnt] = undefined;
				}
			};

			// TODO cors timeout?
			var service = url + &quot;?default-graph-uri=http%3A%2F%2Fdbpedia.org&amp;query=&quot; + encodeURI(query)
					+ &quot;&amp;format=application%2Fsparql-results%2Bjson&amp;timeout=300000&quot;
			&quot;&quot;
			// If no query was passed, exit.
			if (!query) {
				alert(&#x27;No query was passed.&#x27;);
			}
			$.ajax({
				type : &#x27;post&#x27;,
				dataType : &quot;json&quot;,
				url : service,
				success : window[&quot;cbFunc&quot; + cnt],
				error : function(jqXHR, textStatus, errorThrown) {
					console.log(&quot;Error on cors query.&quot;);
					console.log(errorThrown);
					window[&quot;cbFunc&quot; + cnt]();
				}
			});
		};

		this._yqlRequestSPARQL = function(query, url, callback) {
			var success = false, cnt = counter++;
			// Use cnt to stop callbackoverwriting on simultan calls
			window[&quot;cbFunc&quot; + cnt] = function(data, textStatus, jqXHR) {

				// If we have something to work with...
				if (data &amp;&amp; data.query &amp;&amp; data.query.results) {
					success = true;
					callback(data.query.results.sparql.result, success);
				}

				// Else, Maybe we requested a site that doesn&#x27;t exist, and
				// nothing returned.
				else {
					console.log(&#x27;Nothing returned from getJSON.&#x27;);
					callback(null, success);

					// Delete old callbackfunction
					window[&quot;cbFunc&quot; + cnt] = undefined;
				}
			};

			// If no query was passed, exit.
			if (!query) {
				alert(&#x27;No query was passed.&#x27;);
			}

			// Take the provided url, and add it to a YQL query. Make sure you
			// encode it!
			var yql = &#x27;http://query.yahooapis.com/v1/public/yql?q=&#x27;
					+ encodeURIComponent(&#x27;use &quot;http://triplr.org/sparyql/sparql.xml&quot; as sparql; select * from sparql where query=&quot;&#x27;
							+ query + &#x27;&quot; and service=&quot;&#x27; + url) + &#x27;&quot;&amp;format=json&#x27;;

			// Request that YSQL string, and run a callback function.
			// Pass a defined function to prevent cache-busting.
			// $.getJSONP(yql, cbFunc);
			$.ajax({
				type : &#x27;post&#x27;,
				dataType : &#x27;json&#x27;,
				url : yql,
				success : window[&quot;cbFunc&quot; + cnt],
				error : function(jqXHR, textStatus, errorThrown) {
					// console.log(yql);
					console.log(&quot;Error on yql query.&quot;);
					// console.log(textStatus);
					// console.log(jqXHR);
					console.log(errorThrown);
					window[&quot;cbFunc&quot; + cnt]();
				}
			});
		};

	};

	/**
	 * Method for querying the given url with given query. Executes given
	 * callback function with results.
	 * 
	 * @method executeQuery
	 * @param {String}
	 *           query Query to execute
	 * @param {String}
	 *           url URL of service to execute the query on
	 * @param {Function}
	 *           callback Callback function to be executed with query results
	 */
	RemoteEngine.prototype.executeQuery = function(query, url, callback) {
		if (url.indexOf(&quot;yql:&quot;) === 0) {
			this._yqlRequestSPARQL(query, url.slice(4), callback);
		} else {
			this._corsRequestSPARQL(query, url, callback);
		}
	};

	// ========================= Cache class ===============================
	/**
	 * This class defines a cache.
	 * 
	 * @class Cache
	 * @constructor
	 */
	var Cache = function() {
		this.values = {};
	};

	/**
	 * Adds the key and value to the cache.
	 * 
	 * @method add
	 * @param {String}
	 *           key Key to map to the value
	 * @param {String}
	 *           val Value to add to the cache
	 */
	Cache.prototype.add = function(key, val) {
		this.values[key] = val;
	};

	/**
	 * Retrives the to the key correspondending value
	 * 
	 * @method retrieve
	 * @param {String}
	 *           key Key to map to the value
	 * @return {String} Value to which the key maps
	 */
	Cache.prototype.retrieve = function(key) {
		return this.values[key];
	};

	/**
	 * Check if the cache contains a value for the given key
	 * 
	 * @method contains
	 * @param {String}
	 *           key Key to map to the value
	 * @return {Boolean} true if cache contains a value for the given key
	 */
	Cache.prototype.contains = function(key) {
		return key in this.values;
	};

	// ========================= Variables for all bSynopsis instances
	/**
	 * class public functions
	 * 
	 * @class bSynopsis_GLOBAL
	 */

	// Deferred to inform if the plugin was already initialized once
	var globalInitDfd = $.Deferred(),
	// Name of the plugin
	pluginName = &quot;bSynopsis&quot;,
	// rdf store instance(SPARQL endpoint)
	rdfStore,
	// remoteEngine for remote queries
	remoteDataLoader, queryStore,
	// rdf store instance(SPARQL endpoint)
	eventManagers = [],
	// cache for predicate labels
	labelCache = new Cache(),
	// transition end event name
	transEndEventName = getTransEndEventName(),
	// transitions support available?
	supportTransitions = Modernizr.csstransitions,
	// namespaces variable with defaultnamespaces
	namespaces = {
		&#x27;rdf&#x27; : &#x27;http://www.w3.org/1999/02/22-rdf-syntax-ns#&#x27;,
		&#x27;rdfs&#x27; : &#x27;http://www.w3.org/2000/01/rdf-schema#&#x27;,
		&#x27;owl&#x27; : &#x27;http://www.w3.org/2002/07/owl#&#x27;,
		&#x27;rif&#x27; : &#x27;http://www.w3.org/2007/rif#&#x27;,
		&#x27;foaf&#x27; : &#x27;http://xmlns.com/foaf/0.1/&#x27;,
		&#x27;dbpedia&#x27; : &#x27;http://dbpedia.org/resource/&#x27;,
		&#x27;dbpedia-owl&#x27; : &#x27;http://dbpedia.org/ontology/&#x27;,
		&#x27;dbpprop&#x27; : &#x27;http://dbpedia.org/property/&#x27;,
		&#x27;geo&#x27; : &#x27;http://www.w3.org/2003/01/geo/wgs84_pos#&#x27;,
		&#x27;dc&#x27; : &#x27;http://purl.org/dc/terms/&#x27;
	},
	// handlebars templates for the plugin
	templates = {},
	// Counter for plugin ids
	idCounter = 0,
	// Counter for layer ids
	layerIdCounter = 0,
	// Counter for view ids
	viewIdCounter = 0,
	// zIndex counter to show overlays
	zIndex = 2,
	// Counter for listener ids
	listenerId = 0;
	// Returns a unique PluginID
	/**
	 * Generate an ID for the plugin.
	 * 
	 * @method generateId
	 * @return {Integer} ID of the plugin
	 */
	function generateId() {
		return idCounter++;
	}

	// ========================= bSynopsis: Event Class
	Plugin.Event = function(sender) {
		this._sender = sender;
		this._listeners = {};
		this._oneTimeListeners = {};
	};

	Plugin.Event.prototype = {
		attach : function(listener) {
			this._listeners[listener.id] = listener;
		},
		once : function(listener) {
			this._oneTimeListeners[listener.id] = listener;
		},
		dettach : function(listener) {
			delete this._listeners[listener.id];
		},
		notify : function(args) {
			var sender = this._sender, that = this;
			$.each(this._listeners, function(i, val) {
				val.fn(sender, args);
			});
			$.each(this._oneTimeListeners, function(i, val) {
				val.fn(sender, args);
				delete that._oneTimeListeners[i];
			});
		}
	};

	// ========================= bSynopsis: Switch Class
	Plugin.Switch = function(sender) {
		this._sender = sender;
		this._listeners = {};
		this._triggered = false;
	};

	Plugin.Switch.prototype = {
		attach : function(listener) {
			if (this._triggered) {
				listener.fn(this._sender, this._args);
			} else {
				this._listeners[listener.id] = listener;
			}
		},
		trigger : function(args) {
			this._triggered = true;
			this._args = args;
			var that = this;
			$.each(this._listeners, function(i, val) {
				val.fn(that._sender, args);
				delete that._listeners[i];
			});
		}
	};

	// ========================= bSynopsis: Listener Class
	Plugin.Listener = function(fn) {
		this.id = &quot;listener&quot; + listenerId++;
		this.fn = fn;
	};
	// ========================= bSynopsis: eventManager Class
	/**
	 * Class to manage eventHandlers
	 * 
	 * @class Plugin.EventManager
	 * @constructor
	 * @param {jQuery}
	 *           stdObject Default object for adding of eventHandlers
	 */
	Plugin.EventManager = function(stdObject) {
		if (!stdObject) {
			print(&quot;EventManager not created&quot;);
			return false;
		}
		this.stdObject = stdObject;

		// History of event handler bindings
		this._evHandlerHistory = {};
	};

	/**
	 * Add an event handler to given object. Save it in the history for cleanup
	 * purposes.
	 * 
	 * @method addEventHandler
	 * @param {String}
	 *           eventType Type of the event as defined in cons
	 * @param {Function}
	 *           handler Eventhandler function to trigger on event
	 * @param {String}
	 *           object Object to add the eventhandler to
	 * @param {String}
	 *           id ID to add to the eventhandler
	 */
	Plugin.EventManager.prototype.addEventHandler = function(eventType, handler, object, id) {
		var that = this;
		if (object === undefined) {
			object = that.stdObject;
		}
		if (that._evHandlerHistory[eventType] === undefined) {
			that._evHandlerHistory[eventType] = [];
		}
		that._evHandlerHistory[eventType].push({
			&quot;id&quot; : id,
			&quot;object&quot; : object,
			&quot;handler&quot; : handler
		});
		object.on(eventType, handler);
	};

	/**
	 * Remove an event handler from given object and history. Removal by id is
	 * possible.
	 * 
	 * @method removeEventHandler
	 * @param {String}
	 *           eventType Type of the event as defined in CONS
	 * @param {Function}
	 *           id ID of the eventHandler to be removed
	 * @param {String}
	 *           object Object to remove the eventhandler from
	 */
	Plugin.EventManager.prototype.removeEventHandler = function(eventType, id, object) {
		var that = this;
		$.each(that._evHandlerHistory[eventType], function(i, val) {
			if (id === val.id) {
				if (object !== undefined) {
					if ($.data(val.object) === $.data(object)) {
						val.object.off(eventType, val.handler);

						// Stop each on find
						return false;
					}
				} else {

					// Else delete all entries with id
					val.object.off(eventType, val.handler);
				}
			}
		});
	};

	/**
	 * Trigger the event with given parameters on given object.
	 * 
	 * @method trigger
	 * @param {String}
	 *           eventType Type of the event as defined in CONS
	 * @param {Object}
	 *           param Array of parameters to give to the triggered function
	 * @param {String}
	 *           object Object to trigger the event on
	 */
	Plugin.EventManager.prototype.trigger = function(eventType, param, object) {
		if (object) {
			object.trigger(eventType, param);
		} else {
			this.stdObject.trigger(eventType, param);
		}
	};

	/**
	 * Destroy this event manager and all his event handlers.
	 * 
	 * @method destroy
	 */
	Plugin.EventManager.prototype.destroy = function() {
		$.each(this._evHandlerHistory, function(eventType, binding) {
			$.each(binding, function(i, val) {
				val.object.off(eventType, val.handler);
			});
		});
	};

	// ========================= bSynopsis: rdfStore Class
	/**
	 * Class to wrap and create a rdfStore Object. Default: rdfstore-js
	 * https://github.com/antoniogarrote/rdfstore-js
	 * 
	 * @class Plugin.RdfStore
	 * @constructor
	 * @param {Object}
	 *           options Options object for the rdf store
	 * @param {Function}
	 *           callback Callback function to execute after class creation
	 */
	Plugin.RdfStore = function(options, callback) {
		var that = this;
		this._store = null;

		// Prefixes for SPARQL queries
		this._queryPrefixes = &quot;&quot;;

		this._generateQueryPrefix = function(prefix, uri) {
			that._queryPrefixes += &quot;PREFIX &quot; + prefix + &quot;: &lt;&quot; + uri + &quot;&gt; &quot;;
		};

		$.each(namespaces, function(i, val) {
			that._generateQueryPrefix(i, val);
		});

		// Init rdfstore-js
		new rdfstore.Store(options, function(store) {
			that._store = store;
			callback();
		});
		// TODO store as worker?
		// rdfstore.connect(&quot;js/lib/rdfstore-js/index.js&quot;, options,
		// function(success, store) {
		// if(success) {
		// // store is a connection to the worker
		// console.log(store.isWebWorkerConnection === true);
		// } else {
		// // connection was not possible. A store object has been returned
		// instead
		// print(&quot;fail on webworker store&quot;);
		// }
		// that._store = store;
		// callback();
		// });
	};

	/**
	 * Inserts given data in the store
	 * 
	 * @method insertData
	 * @param {String}
	 *           data Data to insert into the store
	 * @param {String}
	 *           dataFormat Format of given data
	 * @param {Function}
	 *           callback Callback function to be called after loading in the
	 *           store.
	 */
	Plugin.RdfStore.prototype.insertData = function(data, dataFormat, callback) {
		var that = this;

		if (dataFormat === &quot;text/turtle&quot; || dataFormat === &quot;text/plain&quot; || dataFormat === &quot;text/n3&quot;) {
			// get prefix terms and update namespaces
			var prefixTerms = data.match(/.*@prefix.*&gt;(\s)*./g);
			if (prefixTerms) {
				$.each(prefixTerms, function(i, val) {
					var prefixTerm = (val.split(/&gt;(\s)*./)[0]).split(/:(\s)*&lt;/);
					var prefix = prefixTerm[0].replace(/@prefix(\s)*/, &quot;&quot;);
					var uri = prefixTerm[2];
					if (isUndefinedOrNull(namespaces[prefix])) {
						namespaces[prefix] = uri;
						that._generateQueryPrefix(prefix, uri);
					}
				});
			}
		} else if (dataFormat === &quot;application/ld+json&quot; || dataFormat === &quot;application/json&quot;) {
			var prefixes = data[&quot;@context&quot;];
			if (prefixes) {
				$.each(prefixes, function(i, val) {
					if (isUndefinedOrNull(namespaces[val])) {
						namespaces[i] = val;
						that._generateQueryPrefix(i, val);
					}
				});
			}
		}
		this._store.load(dataFormat, data, function(store) {
			callback();
		});
	};

	/**
	 * Executes given query on the store
	 * 
	 * @method executeQuery
	 * @param {String}
	 *           query Data to insert into the store
	 * @param {Function}
	 *           callback Callback function to be called with the results of the
	 *           execution.
	 * @param {Function}
	 *           fail Callback function to be called if the execution fails.
	 */
	Plugin.RdfStore.prototype.executeQuery = function(query, callback, fail) {
		this._store.execute(this._queryPrefixes + query, function(success, results) {
			if (success) {
				callback(results, success);
			} else {
				print(&quot;Error on executing: &quot; + query);
				callback(null, success);
			}
		});
	};

	// ========================= bSynopsis: LayoutEngine Class
	/**
	 * Layout engine to add items to. Default: jQuery.isotope
	 * http://isotope.metafizzy.co/
	 * 
	 * @class Plugin.LayoutEngine
	 * @constructor
	 * @param {jQuery}
	 *           container Container to use the layout engine on
	 * @param {Object}
	 *           options Options object for the layout engine
	 */
	Plugin.LayoutEngine = function($container, options) {
		var engine = this;
		this._options = options;
		this._container = $container;
		this._funcQueue = [];
		this._occupied = false;
		this._internDoneEvent = new Plugin.Event(this);
		this.partialDoneEvent = new Plugin.Event(this);
		this.doneEvent = new Plugin.Event(this);
		this._internDoneEvent.attach(new Plugin.Listener(function(sender) {
			engine._addNext();
		}));

		$container.addClass(&quot;layoutEngine&quot;);
		$container.css({
			&quot;overflow&quot; : &quot;hidden&quot;
		});
	};

	Plugin.LayoutEngine.prototype._addNext = function(items) {
		if (this._funcQueue.length &gt; 0) {
			setTimeout(this._funcQueue.shift(), this._options.clusterWait);
		} else {
			this._occupied = false;
			if (this.startTime) {
				print(&quot;Unoccupy. All layouting done after &quot; + (new Date().getTime() - this.startTime) + &quot; ms&quot;);
				this.doneEvent.notify();
				this.startTime = undefined;
			}
		}
	}

	Plugin.LayoutEngine.prototype._setStartTime = function(items) {
		if (!this.startTime) {
			this.startTime = new Date().getTime();
		}
	}

	Plugin.LayoutEngine.prototype.add = function(items) {
	};

	Plugin.LayoutEngine.prototype.remove = function(items, callback) {
	};

	Plugin.LayoutEngine.prototype.removeAll = function(callback) {
	};

	Plugin.LayoutEngine.prototype.updateOptions = function(options) {
	};

	Plugin.LayoutEngine.prototype.sort = function(opts) {
	};

	Plugin.LayoutEngine.prototype.filter = function(fn) {
	};

	Plugin.LayoutEngines = {};

	Plugin.LayoutEngines.Isotope = function($container, options) {
		Plugin.LayoutEngine.call(this, $container, options);
		var engine = this;
		this._container.isotope(options.isotope.options);
		this._container.isotope(&#x27;on&#x27;, &#x27;layoutComplete&#x27;, function() {
			engine._internDoneEvent.notify();
		});
	}

	Plugin.LayoutEngines.Isotope.prototype = Object.create(Plugin.LayoutEngine.prototype);
	Plugin.LayoutEngines.Isotope.prototype.constructor = Plugin.LayoutEngines.Isotope;

	/**
	 * Adds items to the layout engine
	 * 
	 * @method add
	 * @param {jQuery}
	 *           items Div boxes which are to be added
	 * @param {Function}
	 *           callback Callback function
	 */
	Plugin.LayoutEngines.Isotope.prototype.add = function(items) {
		var engine = this;
		engine._setStartTime();
		var fn = function(input) {
			return function() {
				engine._occupied = true;
				var stepSize = engine._options.clusterSize;
				if (items.length &gt; stepSize &amp;&amp; stepSize &gt; 0) {
					var tmp = items;
					tmp = tmp.slice(stepSize);
					items = items.slice(0, stepSize);
					engine.add(tmp);
				}
				var timeStamp = new Date().getTime();
				engine._container.isotope(&#x27;once&#x27;, &#x27;layoutComplete&#x27;, function() {
					print(&quot;Added items to layoutEngine in &quot; + (new Date().getTime() - timeStamp) + &quot; ms&quot;);
					engine.partialDoneEvent.notify(items);
				});
				engine._container.isotope(&quot;insert&quot;, items);
			};
		};
		if (items) {
			if (!this._occupied) {
				fn(items)();
			} else {
				this._funcQueue.push(fn(items));
			}
		}
	};

	/**
	 * Redo the layout of the div boxes
	 * 
	 * @method reLayout
	 */
	Plugin.LayoutEngines.Isotope.prototype.reLayout = function() {
		this._container.isotope(&quot;reLayout&quot;);
	};

	/**
	 * Remove items from the layout engine
	 * 
	 * @method remove
	 * @param {jQuery}
	 *           items Div boxes which are to be removed
	 * @param {Function}
	 *           callback Callback function
	 */
	Plugin.LayoutEngines.Isotope.prototype.remove = function(items, callback) {
		this._container.isotope(&quot;remove&quot;, items, callback);
	};

	Plugin.LayoutEngines.Isotope.prototype.removeAll = function(callback) {
		this._container.html(&#x27;&#x27;);
	};

	/**
	 * Update the options of the layout engine
	 * 
	 * @method updateSortData
	 * @param {Object}
	 *           options Options object of the layout engine
	 */
	Plugin.LayoutEngines.Isotope.prototype.updateOptions = function(options) {
		this._container.isotope(options);
	};

	/**
	 * Update the sort data of the layout engine on specified items
	 * 
	 * @method updateSortData
	 * @param {item}
	 *           item Items for which sort data should be updated
	 */
	Plugin.LayoutEngines.Isotope.prototype.sort = function(name, fn) {
		this.startTime = new Date().getTime();
		if (!this._options.isotope.options.getSortData.hasOwnProperty(name)) {
			var tmpSD = {};
			tmpSD[name] = fn;
			print(&quot;adding tmpSD&quot;);
			this.updateOptions({
				getSortData : tmpSD
			});
		}
		this.updateOptions({
			sortBy : name
		});
	};

	Plugin.LayoutEngines.Isotope.prototype.filter = function(selector) {
		this.startTime = new Date().getTime();
		if (selector !== &#x27;&#x27;) {
			if (selector !== &#x27;*&#x27;) {
				if (this._options.supportRegExpFilter) {
					try {
						selector = &quot;div:regex(class, &quot; + selector + &quot;), div &gt; div:contains(&quot; + selector + &quot;)&quot;;
					} catch (e) {
						selector = &quot;div &gt; div:contains(&quot; + selector + &quot;)&quot;;
					}
				} else {
					selector = &quot;div &gt; div:contains(&quot; + selector + &quot;)&quot;;
				}
			}
		} else {
			selector = &#x27;*&#x27;;
		}
		this.updateOptions({
			filter : selector
		});
	};
	Plugin.LayoutEngines.Shuffle = function($container, options) {
		Plugin.LayoutEngine.call(this, $container, options);
		var engine = this;
		this._container.shuffle(options.shuffle.options);
		this._container.on(&#x27;layout.shuffle&#x27;, function() {
			engine._internDoneEvent.notify();
		});
	}

	Plugin.LayoutEngines.Shuffle.prototype = Object.create(Plugin.LayoutEngine.prototype);
	Plugin.LayoutEngines.Shuffle.prototype.constructor = Plugin.LayoutEngines.Shuffle;

	/**
	 * Adds items to the layout engine
	 * 
	 * @method add
	 * @param {jQuery}
	 *           items Div boxes which are to be added
	 * @param {Function}
	 *           callback Callback function
	 */
	Plugin.LayoutEngines.Shuffle.prototype.add = function(items) {
		var engine = this;
		engine._setStartTime();
		var fn = function(items) {
			return function() {
				engine._occupied = true;
				var stepSize = engine._options.clusterSize;
				if (items.length &gt; stepSize &amp;&amp; stepSize &gt; 0) {
					var tmp = items;
					tmp = tmp.slice(stepSize);
					items = items.slice(0, stepSize);
					engine.add(tmp);
				}
				var timeStamp = new Date().getTime();
				engine._container.one(&#x27;layout.shuffle&#x27;, function() {
					print(&quot;Added items to layoutEngine in &quot; + (new Date().getTime() - timeStamp) + &quot; ms&quot;);
					engine.partialDoneEvent.notify(items);
				});
				engine._container.append(items);
				engine._container.shuffle(&quot;appended&quot;, items);
			};
		};
		if (items) {
			if (!this._occupied) {
				fn(items)();
			} else {
				this._funcQueue.push(fn(items));
			}
		}
	};

	/**
	 * Remove items from the layout engine
	 * 
	 * @method remove
	 * @param {jQuery}
	 *           items Div boxes which are to be removed
	 * @param {Function}
	 *           callback Callback function
	 */
	Plugin.LayoutEngines.Shuffle.prototype.remove = function(items) {
		this._container.shuffle(&#x27;remove&#x27;, items);
	};

	Plugin.LayoutEngines.Shuffle.prototype.removeAll = function(callback) {
		this._container.html(&#x27;&#x27;);
	};

	/**
	 * Update the options of the layout engine
	 * 
	 * @method updateOptions
	 * @param {Object}
	 *           options Options object of the layout engine
	 */
	Plugin.LayoutEngines.Shuffle.prototype.updateOptions = function(options) {
		this._container.shuffle(options);
	};

	Plugin.LayoutEngines.Shuffle.prototype.sort = function(name, fn) {
		this.startTime = new Date().getTime();
		this._container.shuffle(&#x27;sort&#x27;, {
			by : fn
		});
	};

	Plugin.LayoutEngines.Shuffle.prototype.filter = function(selector, type, fn) {
		this.startTime = new Date().getTime();
		var tmp;
		if (typeof fn === &quot;function&quot;) {
			tmp = fn;
		} else if (this.options.shuffle.filterFns.hasOwnProperty(type)) {
			tmp = this.options.shuffle.filterFns[type];
		}
		this._container.shuffle(&#x27;shuffle&#x27;, tmp);
	};
	Plugin.LayoutEngineFactory = {
		make : function($container, options) {
			var engine;
			print(options);
			switch (options.useEngine) {
			case &quot;isotope&quot;:
				engine = new Plugin.LayoutEngines.Isotope($container, options);
				break;
			case &quot;shuffle&quot;:
				engine = new Plugin.LayoutEngines.Shuffle($container, options);
				break;
			default:
				alert(&quot;No layout engine defined.&quot;);
			}
			return engine;
		}
	}

	// ========================= bSynopsis: Node Class
	/**
	 * Base node to represent an abstract element of the rdf graph.
	 * 
	 * @class Plugin.Node
	 * @constructor
	 * @param {Object}
	 *           data Data of a single resource of a select query. Must contain
	 *           index.
	 */
	Plugin.Node = function(data, style) {
		this.id = data.index; // ID for this node
		this.type = CONS.NODE_TYPES.stdNode; // Node Type
		this.useTemplateID = this.type; // Use Templated stored under this name
		this.filterables = []; // Classes used for filtering
		this.components = {}; // Components of the node
		this.style = style;
		if (data.predicate) { // Empty predicates are possible on init view
			this.filterables.push(UTIL.toFilterable(data.predicate.type));
			data.predicate.value = decodeURIComponent(data.predicate.value);
			this.addComponent(&quot;predicate&quot;, data.predicate);
		}
		if (data.description) {
			data.description.value = decodeURIComponent(data.description.value);
			this.addComponent(&quot;description&quot;, data.description);
		}
	};

	/**
	 * Add a new component to this node
	 * 
	 * @method addNewComponent
	 */
	Plugin.Node.prototype.addComponent = function(type, data, style) {
		if (!this.components[type]) { // Increase counter
			this.components[type] = [];
		}
		var id = type + this.components[type].length;
		this.components[type].push(Plugin.ComponentFactory.makeComp(id, type, data, style));
	}

	/**
	 * Check if node has this component type and get the first component of this
	 * type. Returns false if no object is found.
	 * 
	 * @method getFComponentOT
	 * @param {String}
	 *           type Type to look for.
	 * @returns {Object}
	 */
	Plugin.Node.prototype.getFComponentOT = function(type) { // Increment
		// counter and
		// return
		if (this.components[type]) {
			return this.components[type][0];
		} else {
			return false;
		}
	}

	/**
	 * Check if node has a component of this type. Returns Boolean.
	 * 
	 * @method hasComponentType
	 * @param {String}
	 *           type Type to look for.
	 * @returns {Boolean}
	 */
	Plugin.Node.prototype.hasComponentType = function(type) { // Increment
		// counter and
		// return
		return this.components.hasOwnProperty(type);
	}

	/**
	 * Execute function for each component of given type.
	 * 
	 * @method forEachComponentType
	 * @param {string}
	 *           type Type to look for.
	 * @param {function}
	 *           fn Function to execute.
	 * @returns {Object}
	 */
	Plugin.Node.prototype.forEachComponentType = function(type, fn) {
		if (this.components[type]) {
			for (var i = 0; i &lt; this.components[type].length; i++) {
				fn(this.components[type][i]);
			}
		}
	}

	/**
	 * Return type of node
	 * 
	 * @method getType
	 */
	Plugin.Node.prototype.getType = function() {
		return this.type;
	};

	/**
	 * Return template name to use for this node
	 * 
	 * @method getTemplateIdentifier
	 * @returns {String}
	 */
	Plugin.Node.prototype.getTemplateIdentifier = function() {
		return this.useTemplateID;
	};

	/**
	 * Set label of predicate with given position number.
	 * 
	 * @method setPredicateLabel
	 * @param {Integer}
	 *           ind
	 * @param{String} label
	 */
	Plugin.Node.prototype.setPredicateLabel = function(i, label) {
		this.components.predicate[i].label = label;
	};

	/**
	 * Generate tile out of the node and return it.
	 * 
	 * @method generateTile
	 * @returns {jQuery}
	 */
	Plugin.Node.prototype.generateTile = function() {
		var $tile = $(templates[&quot;tileWrapper&quot;](appendCssClasses({
			node : this
		}))).append($(templates[this.useTemplateID](appendCssClasses({
			node : this
		}))));
		$tile.data(&quot;node&quot;, this);
		return $tile;
	};

	// TODO do this in workers cause of performance
	/**
	 * Merges data of given node with own data.
	 * 
	 * @method setPredicateLabel
	 * @param {Node}
	 *           otherNode
	 * @returns {Boolean}
	 */
	Plugin.Node.prototype.merge = function(otherNode) {
		var that = this, update = false;
		$.each(otherNode.components, function(typeID, comps) {
			$.each(comps, function(i, comp) {
				var insert = true;
				if (that.components[typeID]) {
					for (var j = 0; j &lt; that.components[typeID].length; j++) {
						if (comp.equals(that.components[typeID][j])) {
							insert = false;
							break;
						}
					}
				}
				if (insert) {
					that.addComponent(typeID, comp.data);
					update = true;
				}
			});
		});
		return update;
	};

	/**
	 * Node component to be shown on a tile
	 * 
	 * @class Plugin.Node
	 * @constructor
	 * @param {Object}
	 *           data Data of a single resource of a select query. Must contain
	 *           label and index.
	 */
	Plugin.Node.Component = function(id, type, data, style) {
		this.id = id;
		this.type = type;
		this.data = data;
		this.style = style;
	};

	/**
	 * Class to construct nodes out of sparql result sets.
	 * 
	 * @class Plugin.ComponentFactory
	 * @constructor
	 * @param {Object}
	 *           data Data of a single resource of a select query.
	 */
	Plugin.ComponentFactory = {
		// TODO equality etc
		makeComp : function(id, type, data, style) {
			var comp;
			if (style) {
				comp = new Plugin.Node.Component(id, type, data, style);
			} else {
				comp = new Plugin.Node.Component(id, type, data);
			}
			switch (type) {
			case CONS.COMP_TYPES.predicate:
				comp.equals = function(other) {
					return (this.type === other.type) &amp;&amp; (this.data.value === other.data.value);
				}
				break;
			case CONS.COMP_TYPES.label:
				comp.equals = function(other) {
					return (this.type === other.type) &amp;&amp; (this.data.value === other.data.value);
				}
				break;
			case CONS.COMP_TYPES.uri:
				comp.equals = function(other) {
					return (this.type === other.type) &amp;&amp; (this.data === other.data);
				}
				break;
			default:
				comp.equals = function(other) {
					return (this.type === other.type) &amp;&amp; (this.data.value === other.data.value);
				}
				console.log(CONS.MESSAGES.error.compType + type);
			}
			return comp;
		}
	};

	Plugin.Nodes = {};

	/**
	 * Extension of base node to represent an std element of the rdf graph.
	 * 
	 * @class Plugin.Nodes.Res
	 * @extendes Plugin.Node
	 * @constructor
	 * @param {Object}
	 *           data Data of a single resource of a select query. Must contain
	 *           label and index.
	 */
	Plugin.Nodes.Res = function(data) {
		// Call node constructor
		Plugin.Node.call(this, data);
		var that = this;
		// Function for ID generation
		var generateID = function() {
			var id = that.components.uri[0].data;
			that.forEachComponentType(&quot;predicate&quot;, function(predicate) {
				id += &quot;_&quot; + predicate.data.value;
			});
			return id;
		};
		this.type = CONS.NODE_TYPES.resNode; // Overwrite std node type
		this.addComponent(&quot;uri&quot;, data.subject.value, {
			display : &quot;none&quot;
		});
		if (isUndefinedOrNull(data.label)) {
			this.addComponent(&quot;label&quot;, {
				value : decodeURIComponent(this.uri)
			});
		} else {
			data.label.value = decodeURIComponent(data.label.value);
			this.addComponent(&quot;label&quot;, data.label);
		}
		this.id = generateID(); // Overwrite id
	};

	Plugin.Nodes.Res.prototype = Object.create(Plugin.Node.prototype);
	Plugin.Nodes.Res.prototype.constructor = Plugin.Nodes.Res;

	/**
	 * Generate tile out of node and return it.
	 * 
	 * @overwrites Plugin.Node.prototype.generateTile
	 * @method generateTile
	 * @returns {jQuery}
	 */
	Plugin.Nodes.Res.prototype.generateTile = function() {
		var $tile = Plugin.Node.prototype.generateTile.call(this);
		return $tile;
	}

	/**
	 * Extension of base node to represent an literal element of the rdf graph.
	 * 
	 * @class Plugin.Nodes.Literal
	 * @extendes Plugin.Node
	 * @constructor
	 * @param {Object}
	 *           data Data of a single resource of a select query.
	 */
	Plugin.Nodes.Literal = function(data) {
		var that = this;
		// Call node constructor
		Plugin.Node.call(this, data);
		// Function for ID generation
		var generateID = function() {
			var id = that.getFComponentOT(&quot;label&quot;).data.value;
			that.forEachComponentType(&quot;predicate&quot;, function(predicate) {
				id += &quot;_&quot; + predicate.data.value;
			});
			return id;
		};
		this.type = CONS.NODE_TYPES.literal;
		data.subject.value = decodeURIComponent(data.subject.value);
		this.addComponent(&quot;label&quot;, data.subject);
		this.id = generateID();
	};

	Plugin.Nodes.Literal.prototype = Object.create(Plugin.Node.prototype);
	Plugin.Nodes.Literal.prototype.constructor = Plugin.Nodes.Literal;

	/**
	 * Generate tile out of node and return it.
	 * 
	 * @overwrites Plugin.Node.prototype.generateTile
	 * @method generateTile
	 * @returns {jQuery}
	 */
	Plugin.Nodes.Literal.prototype.generateTile = function() {
		var $tile = Plugin.Node.prototype.generateTile.call(this);
		return $tile;
	};

	/**
	 * Extension of base node to represent an literal element of the rdf graph.
	 * 
	 * @class Plugin.Nodes.Blank
	 * @extendes Plugin.Node
	 * @constructor
	 * @param {Object}
	 *           data Data of a single resource of a select query.
	 */
	Plugin.Nodes.Blank = function(data) {
		// Call node constructor
		Plugin.Node.call(this, data);
		// Function for ID generation
		var generateID = function() {
			return &#x27;_&#x27; + Math.random().toString(36).substr(2, 9); // TODO
		};
		this.type = CONS.NODE_TYPES.blankNode;
		this.addComponent(&quot;label&quot;, {
			value : &quot;BlankNode - TODO&quot;
		});
		this.id = generateID();
	};

	Plugin.Nodes.Blank.prototype = Object.create(Plugin.Node.prototype);
	Plugin.Nodes.Blank.prototype.constructor = Plugin.Nodes.Blank;

	/**
	 * Generate tile out of node and return it.
	 * 
	 * @overwrites Plugin.Node.prototype.generateTile
	 * @method generateTile
	 * @returns {jQuery}
	 */
	Plugin.Nodes.Blank.prototype.generateTile = function() {
		var $tile = Plugin.Node.prototype.generateTile.call(this);
		return $tile;
	};

	/**
	 * Class to construct nodes out of sparql result sets.
	 * 
	 * @class Plugin.NodeFactory
	 * @constructor
	 * @param {Object}
	 *           data Data of a single resource of a select query.
	 */
	Plugin.NodeFactory = {
		make : function(data, options) {
			var node;
			switch (data.subject.token) {
			case UTIL.toToken(CONS.CSS_CLASSES.patternClasses.blanknode):
				node = new Plugin.Nodes.Blank(data);
				break;
			case UTIL.toToken(CONS.CSS_CLASSES.patternClasses.literal):
				node = new Plugin.Nodes.Literal(data);
				break;
			case UTIL.toToken(CONS.CSS_CLASSES.patternClasses.uri):
				if (data.label &amp;&amp; (data.label.lang === undefined || data.label.lang === &quot;en&quot;)) {
					node = new Plugin.Nodes.Res(data);
				}
				break;
			default:
				console.log(CONS.MESSAGES.error.tokenType + data.subject.token);
			}
			return node;
		}
	};

	// ========================= bSynopsis: Timeline Class
	/**
	 * Timeline
	 * 
	 * @class Plugin.TimeLine
	 * @constructor
	 */
	Plugin.TimeLine = function($parent) {
		this._$timelineContainer = $(&#x27;&lt;div class=&quot;&#x27; + CONS.CSS_CLASSES.timelineContainer + &#x27;&quot;&gt;&#x27;);
		$parent.prepend(this._$timelineContainer);
		this._$timeline = $(&#x27;&lt;ul class=&quot;&#x27; + CONS.CSS_CLASSES.timeline + &#x27;&quot;&gt;&lt;/ul&gt;&#x27;);
		this._$timelineContainer.append(this._$timeline);
		this.timeLineNodes = [];
	};

	/**
	 * Open timeline overlay.
	 * 
	 * @method open
	 */
	Plugin.TimeLine.prototype.open = function() {
		if (this._$timelineContainer.data(&quot;isExpanded&quot;)) {
			this._$timelineContainer.data(&quot;isExpanded&quot;, false);
			this._$timelineContainer.css({
				opacity : 0,
				zIndex : -1
			});
		} else {
			this._$timelineContainer.data(&quot;isExpanded&quot;, true);
			this._$timelineContainer.css({
				&quot;background-color&quot; : &quot;grey&quot;,
				opacity : 1,
				zIndex : zIndex++
			});
		}
	};

	/**
	 * Close timeline overlay.
	 * 
	 * @method close
	 */
	Plugin.TimeLine.prototype.close = function() {
		this._$timelineContainer.data(&quot;isExpanded&quot;, false);
		this._$timelineContainer.css({
			opacity : 0,
			zIndex : -1
		});
	};

	/**
	 * Add layer to timeline via timeLineNode generation.
	 * 
	 * @method addLayer
	 * @param {Plugin.Layer}
	 *           layer Layer object to be added to timeline.
	 */
	Plugin.TimeLine.prototype.addLayer = function(layer) {
		this.addNode(new Plugin.TimeLine.Node(layer));
	};

	/**
	 * Add TimeLineNode to timeline.
	 * 
	 * @method addNode
	 * @param {Plugin.TimeLine.Node}
	 *           timeLineNode TimeLineNode added to timeline.
	 */
	Plugin.TimeLine.prototype.addNode = function(timeLineNode) {
		var that = this;
		this.timeLineNodes.push(timeLineNode);
		this._$timeline.prepend(timeLineNode.getJQueryObj());
		timeLineNode.clickEvent.attach(new Plugin.Listener(function() {
			that.close();
		}));
	};

	// ========================= bSynopsis: Timeline.Node Class
	/**
	 * Timeline node object to be used in timelines.
	 * 
	 * @class Plugin.TimeLine.Node
	 * @constructor
	 */
	Plugin.TimeLine.Node = function(layer) {
		var that = this;
		this.clickEvent = new Plugin.Event(this);
		this.layer = layer;
		this.$timelineNode = $(templates
				.timelineItem({
					label : (layer.node &amp;&amp; layer.node.hasComponentType(&quot;label&quot;)) ? layer.node
							.getFComponentOT(&quot;label&quot;).data.value : layer.id
				}));
		if (layer.$tile) {
			this.$timelineNode.css({
				&quot;background-color&quot; : layer.$tile.css(&quot;background-color&quot;)
			});
		}
		this.$timelineNode.click(function() {
			that.clickEvent.notify();
			that.layer.open();
			that.layer.update();
		});
	};

	/**
	 * Return jQuery object of timeline node
	 * 
	 * @method getJQueryObj
	 * @returns {JQuery}
	 */
	Plugin.TimeLine.Node.prototype.getJQueryObj = function() {
		return this.$timelineNode;
	};

	// ========================= bSynopsis: Layer Class
	/**
	 * Layer to be shown
	 * 
	 * @class Plugin.Layer
	 * @constructor
	 * @param {jQuery}
	 *           $parent Parent div container
	 * @param {Object}
	 *           options Options object of the view
	 * @param {Object}
	 *           queries Queries to use in the view
	 */
	Plugin.Layer = function($parent, options, queries) {
		var that = this;

		this.initSwitch = new Plugin.Switch(this);
		this.openEvent = new Plugin.Event(this);
		this.closeEvent = new Plugin.Event(this);
		this.filterEvent = new Plugin.Event(this);

		this.id = &quot;layer&quot; + layerIdCounter++;
		this.initDfd = $.Deferred();
		this.$parent = $parent;
		this.options = options;

		// When open
		this.openEvent.once(new Plugin.Listener(function(sender) {
			// When rest is init
			that.initSwitch.attach(new Plugin.Listener(function(sender) {
				that._initContent();
			}));
		}));
		$.when(that._addOverlay()).done(function() {
			$.when(that._addOverlayContent()).done(function() {
				that._initLayerData(queries);
			});
		});
	};

	/**
	 * Private method to init Layer object.
	 * 
	 * @method _initLayerData
	 * @param {Object}
	 *           queries Queries to use for layer init
	 */
	Plugin.Layer.prototype._initLayerData = function(queries) {
		var that = this;

		this.model = new Plugin.Layer.Model(queries, this.options.modelOptions, queryStore.label);
		this.view = new Plugin.Layer.View(this.model, this.$content, this.options.viewOptions);
		// Repaint on added items
		this.model.itemsAdded.attach(new Plugin.Listener(function(sender, args) {
			that.view.addTiles(that.getTilesToPaint(args.addedNodes, that.options.nodeFilters,
					that.options.tileFilters));
		}));

		// Clear view on model clearing
		this.model.modelCleared.attach(new Plugin.Listener(function(sender) {
			print(&quot;Clearing view.&quot;);
			that.view.layoutEngine.remove($(UTIL.toSelector(CONS.CSS_CLASSES.tileClasses.tile)));
		}));

		if (this.options.generateSortOptions || this.options.generateFilterOptions) {
			this.view.addOptionsBox();
			if (this.options.generateSortOptions) {
				this.view.addSorter();
			}
			if (this.options.generateFilterOptions) {
				this.view.appendFilterDiv(function() {
					that.view.addFilterLinkFn();
					that.view.addFilterBoxFn();
				});
			}
		}
		this._addCloseOnClick();
		this._addRefreshOnClick();
		this._addBackgroundColor();
		this.initSwitch.trigger();
	};

	Plugin.Layer.prototype._addBackgroundColor = function() {
		this.$overlay.css(&quot;background-color&quot;, &quot;grey&quot;);
	};

	Plugin.Layer.prototype._addCloseOnClick = function() {
		var that = this;
		var $close = this.$overlay.find(&#x27;&gt; span&#x27; + UTIL.toSelector(CONS.CSS_CLASSES.buttonClose));
		$close.on(&quot;click&quot;, function() {
			that.close();
		});
	};

	Plugin.Layer.prototype._addRefreshOnClick = function() {
		var that = this;
		var $refresh = this.$overlay.find(UTIL.toSelector(CONS.CSS_CLASSES.refresh));
		$refresh.on(&quot;click&quot;, function() {
			that.update();
		});
	};

	Plugin.Layer.prototype.getTimeLineButton = function() {
		return this.$overlay.find(UTIL.toSelector(CONS.CSS_CLASSES.buttonTimeline));
	};

	Plugin.Layer.prototype._addOverlay = function() {
		var overlayAddedDfd = $.Deferred();
		this.$overlay = $(templates.overlayWrapper(appendCssClasses({
			&quot;id&quot; : this.id,
		})));
		this.$parent.append(this.$overlay);
		overlayAddedDfd.resolve();
		return overlayAddedDfd.promise();
	};

	Plugin.Layer.prototype._addOverlayContent = function() {
		var overlayContentAddedDfd = $.Deferred();
		// Dummy content (overwrite it)
		this.$content = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;);
		this.$overlay.append(this.$content);
		overlayContentAddedDfd.resolve();
		return overlayContentAddedDfd.promise();
	};

	Plugin.Layer.prototype._initContent = function() {
		var that = this;
		print(&quot;initContent&quot;);
		if (that.options.remoteOptions.remoteDynamically) {
			if (!that.options.remoteOptions.waitForRemote) {
				that.update();

			}
			if (this.loadByRemote) {
				this.loadByRemote();
			} else {
				print(&quot;LoadByRemote currently not defined&quot;);
			}
		} else {
			this.update();
		}
	};

	/**
	 * Get the div box of the overlay
	 * 
	 * @method getJQueryObj
	 */
	Plugin.Layer.prototype.getJQueryObj = function() {
		return this.$overlay;
	};

	/**
	 * Remove the div box of the overlay
	 * 
	 * @method removeHtml
	 */
	Plugin.Layer.prototype.removeHtml = function() {
		return this.$overlay.remove();
	};

	/**
	 * Call the model update function to start selfupdating of the model
	 * 
	 * @method update
	 */
	Plugin.Layer.prototype.update = function() {
		print(&quot;Layer &quot; + this.id + &quot; is updating.&quot;);
		// print(&quot;Caller is &quot; + arguments.callee.caller.toString());
		this.model.update();
	};

	/**
	 * Method to show the layer
	 * 
	 * @method open
	 */
	Plugin.Layer.prototype.open = function() {
		this.$overlay.data(&quot;isExpanded&quot;, true);
		this.show();
	};

	Plugin.Layer.prototype.show = function() {
		// Make overlay visible
		this.zIndex = zIndex++;
		this.$overlay.css({
			clip : getClip(CONS.CSS_CLASSES.overlay),
			opacity : 1,
			zIndex : this.zIndex,
			pointerEvents : &#x27;auto&#x27;
		});
		this.openEvent.notify();
	};

	Plugin.Layer.prototype.close = function() {
		this.$overlay.data(&quot;isExpanded&quot;, false);
		this.closeEvent.notify();
		this.hide();
	};

	Plugin.Layer.prototype.hide = function() {
		this.$overlay.css({
			opacity : 0,
			zIndex : -1
		});
	};

	/**
	 * Clear the view
	 * 
	 * @method removeAllItems
	 */
	Plugin.Layer.prototype.removeAllItems = function() {
		this.model.clearModel();
	};

	Plugin.Layer.prototype.getTilesToPaint = function(nodes, nodeFilters, tileFilters) {
		return this.runTileFilters(this.generateTiles(this.runNodeFilters(nodes, nodeFilters)), tileFilters)
	};

	Plugin.Layer.prototype.runNodeFilters = function(nodes, nodeFilters) {
		var that = this;
		if (nodeFilters) {
			filters = nodeFilters;
		} else {
			filters = this.options.nodeFilters;
		}

		// Run nodeFilters on nodes
		var allStart = new Date().getTime();
		var startTime = allStart;
		var tmp;
		print(&quot;Start node filters:&quot;);
		$.each(filters, function(i, filter) {
			if (tmp) {
				print(&quot;Filter &quot; + tmp + &quot; done in: &quot; + (new Date().getTime() - startTime) + &quot; milisec&quot;);
			}
			tmp = i;
			startTime = new Date().getTime();
			if (!$.isEmptyObject(nodes)) {
				nodes = filter.fn(nodes, filter.config, that);
			} else {
				console.log(CONS.MESSAGES.warn.filterInput);
			}
		});
		print(&quot;Filter &quot; + tmp + &quot; done in: &quot; + (new Date().getTime() - startTime) + &quot; milisec&quot;);
		print(&quot;All node filter done after: &quot; + (new Date().getTime() - startTime) + &quot; milisec&quot;);
		return nodes;
	};

	Plugin.Layer.prototype.generateTiles = function(nodes, nodeFilters) {
		// Generate all tiles
		var $tiles = $(&quot;&lt;div&gt;&quot;);
		$.each(nodes, function(i, node) {
			$tiles.append($(node.generateTile()));
		});
		return $tiles;
	};

	Plugin.Layer.prototype.runTileFilters = function($tiles, tileFilters) {
		var that = this;

		// Generate all tiles
		if (tileFilters) {
			filters = tileFilters;
		} else {
			filters = this.options.tileFilters;
		}

		// Run tileFilters on tiles
		$tiles = $tiles.children();
		var allStart = new Date().getTime();
		var startTime = allStart;
		var tmp;
		$.each(filters, function(i, filter) {
			if (tmp) {
				print(&quot;Filter &quot; + tmp + &quot; done in: &quot; + (new Date().getTime() - startTime) + &quot; milisec&quot;);
			}
			tmp = i;
			startTime = new Date().getTime();
			$tiles = filter.fn($tiles, filter.config, that);
		});
		print(&quot;Filter &quot; + tmp + &quot; done in: &quot; + (new Date().getTime() - startTime) + &quot; milisec&quot;);
		print(&quot;All tile filters done after: &quot; + (new Date().getTime() - allStart) + &quot; milisec&quot;);
		return $tiles;
	};

	Plugin.Layer.Model = function(viewQueries, options, labelQuery) {

		// TODO Workers
		// var that = this;
		// var nodes = JSON.stringify(this._nodes);
		// print(nodes);
		// //Test
		// $.Hive.create({
		// // optional. if no &#x27;count&#x27; property is set, Hive creates only 1 worker
		// count: 1,
		// // the worker file
		// worker: &#x27;../../workers/model.js&#x27;,
		// // the receive ( convenience to writing out the addEventListener)
		// receive: function (filtered) {
		// /*
		// jQuery.Hive manages serialization/deserialization
		// */
		// console.log(filtered.data);
		//			 
		// },
		// created: function ( $hive ) {
		// /*
		// the &#x60;created&#x60; callback fires after the worker is created,
		// the first argument is an array of the workers
		// $().send() is the wrapper for postMessage() with complete
		// serialization/deserialization
		// */
		// $( $hive ).send({test : nodes});
		// }
		// });
		// print(JSON.parse(nodes));

		var that = this;
		this.viewQueries = viewQueries;
		this.labelQuery = labelQuery;
		this.options = options;

		// List of added items.
		this._nodes = {};
		this.nodesLength = 0;

		this.itemsAdded = new Plugin.Event(this);
		this.modelCleared = new Plugin.Event(this);
		this.itemUpdated = new Plugin.Event(this);

		// Helper for batch adding
		this._checkItemsHelp = function(items, batchSize) {
			var rest = items.slice(batchSize);
			if (rest.length &gt; 0) {
				that.checkItems(rest);
			}
		};

		/**
		 * Fetches and updates the labels of the predicates of given node
		 * 
		 * @private
		 * @method _fetchPredicateLabel
		 * @param {Plugin.Node}
		 *           node Node to fetch the predicate labels for
		 */
		this._fetchPredicateLabel = function(node) {

			if (node.hasComponentType(&quot;predicate&quot;)) {
				for (var i = 0; i &lt; node.components.predicate.length; i++) {
					var predicate = node.components.predicate[i];
					if (!labelCache.contains(predicate.value)) {
						var labelQuery = replaceDummy(that.labelQuery, predicate.value);
						rdfStore.executeQuery(labelQuery, function(results) {
							if (results &amp;&amp; results[0]) {
								$.each(results, function(i, result) {
									node.setPredicateLabel(i, result.label.value);
									labelCache.add(predicate.value, result.label.value);
								});
							}
						});
					} else {
						node.setPredicateLabel(i, labelCache.retrieve(predicate.value));
					}
				}
			}
			return node;
		};

	};

	/**
	 * Give back a copy of in model stored nodes
	 * 
	 * @return {Object} nodes A copy of the stored nodes
	 */
	Plugin.Layer.Model.prototype.getNodes = function() {
	};

	/**
	 * Look in given resultSet for Items to add to the model.
	 * 
	 * @method checkItems
	 * @param {Object}
	 *           resultSet ResultSet of a Select query
	 */
	Plugin.Layer.Model.prototype.checkItems = function(resultSet) {
		var length = resultSet.length, that = this, batchSize = ((length &lt; that.options.batchSize) ? length
				: that.options.batchSize);

		// current batch
		var batch = resultSet.slice(0, batchSize);
		var addedNodes = {};

		$.each(batch, function(i, val) {
			val.subject.token = UTIL.toToken(UTIL.toClass(val.subject.token));
			val.index = that.nodesLength + 1;
			var node = Plugin.NodeFactory.make(val, that.options);

			if (node) {

				switch (node.getType()) {
				case CONS.NODE_TYPES.resNode:
					if (!(node.id in that._nodes)) {
						that._nodes[node.id] = node;
						that.nodesLength++;
					} else {
						print(&quot;resNodeUpdate, fix me&quot;);
						if (that._nodes[node.id].merge(node)) {
							node = that._nodes[node.id];
							that.itemUpdated.notify(node);
						} else {
							node = undefined;
						}
					}
					break;
				case CONS.NODE_TYPES.literal:
					if (!(node.id in that._nodes)) {
						that._nodes[node.id] = node;
						that.nodesLength++;
					} else {
						print(&quot;literalupdate&quot;);
						if (that._nodes[node.id].merge(node)) {
							node = that._nodes[node.id];
							that.itemUpdated.notify(node);
						} else {
							node = undefined;
						}
					}
					break;
				case CONS.NODE_TYPES.blankNode:
					if (!(node.id in that._nodes)) {
						that._nodes[node.id] = node;
						that.nodesLength++;
					} else {
						// TODO check blankNode UPDATE ?
						print(&quot;blankNodeupdate&quot;);
						node = undefined;
					}
					break;
				}
				if (node) {
					node = that._fetchPredicateLabel(node);
					addedNodes[node.id] = node;
				}
			}
		});
		print(addedNodes);
		this.itemsAdded.notify({
			&quot;addedNodes&quot; : addedNodes,
			&quot;allNodes&quot; : this.getNodes()
		});
		that._checkItemsHelp(resultSet, batchSize);
	};

	/**
	 * Get data for the model by querying the local store
	 * 
	 * @method update
	 */
	Plugin.Layer.Model.prototype.update = function() {
		print(&quot;START&quot;);
		var that = this;
		this.allResults = [];
		// Concat all results for filtering before adding
		for (var i = 0; i &lt; this.viewQueries.length; i++) {
			print(this.viewQueries[i].query);
			rdfStore.executeQuery(this.viewQueries[i].query, function(results) {
				print(results);
				if (results &amp;&amp; results.length !== 0) {
					for (var j = 0; j &lt; results.length; j++) {
						// Add types for filtering
						if (that.viewQueries[i].type) {
							results[j].predicate.type = that.viewQueries[i].type;
						}
						that.allResults.push(results[j]);
					}
				}
			});
		}

		if (this.allResults.length &gt; 0) {
			that.checkItems(this.allResults);
		} else {
			print(&quot;Nothing to add to View&quot;);
		}
	};

	Plugin.Layer.Model.prototype.clearModel = function() {
		this._nodes = {};
		this.modelCleared.notify();
	};

	Plugin.Layer.View = function(model, $container, viewOptions) {
		this.id = &quot;view&quot; + viewIdCounter++;
		this.options = viewOptions;
		this._model = model;
		this.$outerContainer = $(&#x27;&lt;div class=&quot;&#x27; + CONS.CSS_CLASSES.outerContainer + &#x27;&quot;&gt;&lt;/div&gt;&#x27;);
		this.$outerContainer.css({
			&quot;border-radius&quot; : &quot;18px&quot;,
			&quot;padding&quot; : &quot;5px 5px 5px 5px&quot;
		});
		this.$viewContainer = $(&#x27;&lt;div class=&quot;&#x27; + CONS.CSS_CLASSES.viewContainer + &#x27;&quot;&gt;&lt;/div&gt;&#x27;);
		$container.append(this.$outerContainer);
		this.$outerContainer.append(this.$viewContainer);
		this.$viewContainer.css(&quot;width&quot;, &quot;100%&quot;);
		this.layoutEngine = Plugin.LayoutEngineFactory.make(this.$viewContainer,
				viewOptions.layoutEngineOptions);

		this._getCorrespondingTile = function(node) {
			var $tile = this.$viewContainer.find(UTIL.toClassSelector(node.id));
			print(&quot;CorrespondingTile&quot;);
			print($tile);
			return $tile;
		};
	};

	Plugin.Layer.View.prototype.clearView = function(callback) {
		this.layoutEngine.removeAll(callback);
	};

	Plugin.Layer.View.prototype.removeTiles = function($tiles, callback) {
		var that = this;
		$.each($tiles, function(i, tile) {
			var $tile = $(tile);
			that.layoutEngine.remove($tile);
		});
	};

	Plugin.Layer.View.prototype.addTiles = function($tiles) {
		this.layoutEngine.add($tiles);
	};

	Plugin.Layer.View.prototype.addOptionsBox = function() {
		this.$optionsContainer = $(&#x27;&lt;section class=&quot;&#x27; + CONS.CSS_CLASSES.options + &#x27;&quot; class=&quot;&#x27;
				+ CONS.CSS_CLASSES.clearfix + &#x27;&quot;&gt;&lt;/section&gt;&#x27;);
		this.$outerContainer.prepend(this.$optionsContainer);
	};

	Plugin.Layer.View.prototype.addSorter = function() {
		// Add sortoptions
		var that = this;
		var sortData = $.extend({}, this.options.sortFns);
		var sortOptions = templates.sortOptions(appendCssClasses({
			optionSet : sortData
		}));
		this.$optionsContainer.prepend(sortOptions);
		var $sorter = this.$optionsContainer.find(&#x27; &gt; &#x27; + UTIL.toSelector(CONS.CSS_CLASSES.sorter));
		var $sortLinks = this.$optionsContainer.find(&#x27;a&#x27;);

		// Add onClick
		$sortLinks.click(function() {
			// get href attribute, minus the &#x27;#&#x27;
			var sortName = $(this).attr(&#x27;data-sort-value&#x27;);
			// $sorterGroup.val(&quot;Group by...&quot;);
			that.$optionsContainer.find(UTIL.toSelector(CONS.CSS_CLASSES.sorter) + &#x27; &gt; &gt; &gt; .selected&#x27;)
					.removeClass(&quot;selected&quot;);
			// that.$outerContainer.find(&quot;&gt; &gt; &quot; +
			// UTIL.toSelector(CONS.CSS_CLASSES.groupLabel)).remove();
			$(this).addClass(&quot;selected&quot;);
			that.layoutEngine.sort(sortName, sortData[sortName]);
			return false;
		});
	};

	Plugin.Layer.View.prototype.appendFilterDiv = function(callback) {
		var filterOptions = templates.filterOptions(appendCssClasses({
			filterOptions : this.options.filterBy
		}));
		this.$filter = $(filterOptions);
		this.$optionsContainer.append(this.$filter);
		this.$filterLinks = this.$filter.filter(UTIL.toSelector(CONS.CSS_CLASSES.filter)).find(&quot;a&quot;);
		this.$filterBox = this.$filter.find(&#x27;#filterField&#x27;);
		if (callback) {
			callback();
		}
	}

	Plugin.Layer.View.prototype.addFilterBoxFn = function() {
		var that = this;
		// Add onKey
		this.$filterBox.keyup(function(e) {
			var selector = $(this).val().toLowerCase();
			that.$filterLinks.removeClass(&#x27;selected&#x27;);
			that.layoutEngine.filter(selector, &quot;contains&quot;);
		});
	};

	Plugin.Layer.View.prototype.addFilterLinkFn = function() {
		var that = this;
		// Add onClick
		this.$filterLinks.click(function() {
			var selector = $(this).attr(&#x27;data-filter-value&#x27;);
			if (selector !== &#x27;*&#x27;) {
				selector = &quot;.&quot; + CONS.FA_TAG + selector;
			}
			that.$filterLinks.removeClass(&#x27;selected&#x27;);
			that.$filterBox.val(&#x27;Enter search here.&#x27;);
			$(this).addClass(&#x27;selected&#x27;);
			// TODO filter
			that.layoutEngine.filter(selector, &quot;class&quot;);
			return false;
		});
	};

	// Object for all layer types
	Plugin.Layers = {};

	// ========================= bSynopsis: ResNodeLayer Class
	/**
	 * Initialization view of the plugin
	 * 
	 * @class Plugin.Layers.Res
	 * @extends Plugin.Layer
	 * @constructor
	 * @param {jQuery}
	 *           $container Container of the initialization view
	 * @param {Object}
	 *           options Options object
	 * @param {Plugin}
	 *           plugin The parent plugin of the initialization view
	 */
	Plugin.Layers.Res = function($container, options, $tile) {
		this.$tile = $tile;
		this.node = $tile.data(&quot;node&quot;);

		// Get queries
		var queries = []
		var subjectOfQuery = replaceDummy(queryStore.selectSubjectOf, this.node.getFComponentOT(&quot;uri&quot;).data);
		var objectOfQuery = replaceDummy(queryStore.selectObjectOf, this.node.getFComponentOT(&quot;uri&quot;).data);
		queries.push({
			query : subjectOfQuery,
			type : CONS.CSS_CLASSES.typeClasses.outgoing
		});
		queries.push({
			query : objectOfQuery,
			type : CONS.CSS_CLASSES.typeClasses.incoming
		});
		Plugin.Layer.call(this, $container, options, queries);
	};

	// pseudo class inheritance
	Plugin.Layers.Res.prototype = Object.create(Plugin.Layer.prototype);
	Plugin.Layers.Res.prototype.constructor = Plugin.Layers.Res;

	Plugin.Layers.Res.prototype._addOverlayContent = function() {
		var overlayContentAddedDfd = $.Deferred();
		var $content = this.$overlay.find(UTIL.toSelector(CONS.CSS_CLASSES.overlayContent));
		$content.append($(templates.overlayContent(appendCssClasses({
			node : this.node
		}))));
		this.$content = $content.find(UTIL.toSelector(CONS.CSS_CLASSES.innerScroll));
		// Set innerScrollBox width and height
		this.$content.css(&quot;width&quot;,
				($window.width() - parseInt(this.$overlay.css(&quot;padding-left&quot;)) - parseInt(this.$overlay
						.css(&quot;padding-right&quot;)))
						+ &quot;px&quot;);
		this.$content.css(&quot;height&quot;, $window.height()
				- this.$overlay.find(UTIL.toSelector(CONS.CSS_CLASSES.innerNoScroll)).height() + &quot;px&quot;);
		overlayContentAddedDfd.resolve();
		return overlayContentAddedDfd.promise();
	};

	Plugin.Layers.Res.prototype._addBackgroundColor = function() {
		var color = new RGBColor(this.$tile.css(&quot;background-color&quot;));
		this.$overlay.css(&quot;background-color&quot;, color.toRGB());
		$.each(this.$content.children(&#x27;div&#x27; + UTIL.toSelector(&quot;innerScroll&quot;)), function(i, val) {
			color.r -= 10;
			color.b -= 10;
			color.g -= 10;
			$(val).css(&quot;background&quot;, color.toRGB());
		});
	};

	/**
	 * Load children by remote service
	 * 
	 * @method loadByRemote
	 */
	Plugin.Layers.Res.prototype.loadByRemote = function() {

		var that = this;
		var $innerNoScroll = that.$overlay.find(UTIL.toSelector(CONS.CSS_CLASSES.innerNoScroll));

		$innerNoScroll.css({
			&quot;background-image&quot; : &quot;url(&#x27;img/loader.gif&#x27;)&quot;,
			&quot;background-repeat&quot; : &quot;no-repeat&quot;,
			&quot;background-position&quot; : &quot;center&quot;
		});

		// Get items who are in a relation to
		// current item
		var remoteSubjectOf = replaceDummy(queryStore.remoteSubjectOf, that.node.getFComponentOT(&quot;uri&quot;).data)
				+ &quot; LIMIT &quot; + that.options.remoteOptions.remoteLimit;
		var remoteObjectOf = replaceDummy(queryStore.remoteObjectOf, that.node.getFComponentOT(&quot;uri&quot;).data)
				+ &quot; LIMIT &quot; + that.options.remoteOptions.remoteLimit;

		// multiplactor 2 is num of queries
		var remoteToDo = remoteDataLoader.backends.length * 2;
		var remoteDoneCount = 0;
		remoteDataLoader.loadingDone.attach(new Plugin.Listener(function(e, query) {
			if (query === remoteSubjectOf || query === remoteObjectOf) {
				remoteDoneCount++;
				print(&quot;remoteDoneCount &quot; + remoteDoneCount);
				that.update();
				if (remoteDoneCount === remoteToDo) {
					$innerNoScroll.css({
						&quot;background-image&quot; : &quot;&quot;
					});
					remoteDataLoader.loadingDone.dettach(this);
				}
			}
		}));

		// remote needed?
		remoteDataLoader.insertByQuery(remoteSubjectOf);
		remoteDataLoader.insertByQuery(remoteObjectOf);
	};

	Plugin.Layers.Res.prototype.show = function() {
		// &lt;---- overlay show function ----&gt;
		var that = this;
		this.zIndex = zIndex++;
		var previewClip = getClip(CONS.CSS_CLASSES.preview), overlayClip = getClip(CONS.CSS_CLASSES.overlay);

		// Make overlay visible
		this.$overlay.css({
			clip : supportTransitions ? previewClip : overlayClip,
			opacity : 1,
			zIndex : this.zIndex,
			pointerEvents : &#x27;auto&#x27;
		});

		if (supportTransitions) {
			that.$overlay.on(transEndEventName, function() {
				that.$overlay.off(transEndEventName);
				setTimeout(function() {
					that.$overlay.css(&#x27;clip&#x27;, overlayClip).on(transEndEventName, function() {
						that.$overlay.off(transEndEventName);
						that.openEvent.notify();
					});
				}, 25);

			});
		} else {
			that.openEvent.notify();
		}
		// &lt;!--- overlay show function ----&gt;
	};

	Plugin.Layers.Res.prototype.hide = function() {
		var that = this;
		var layoutProp = getItemLayoutProp(this.$tile), itemClip = &#x27;rect(&#x27; + layoutProp.top + &#x27;px &#x27;
				+ (layoutProp.left + layoutProp.width) + &#x27;px &#x27; + (layoutProp.top + layoutProp.height) + &#x27;px &#x27;
				+ layoutProp.left + &#x27;px)&#x27;;
		// this.$overlay.children().remove(&#x27;&#x27;);
		this.$overlay.css({
			clip : itemClip,
			opacity : 1,
			pointerEvents : &#x27;none&#x27;
		});

		// &lt;---- overlay hide ----&gt;
		if (supportTransitions) {
			that.$overlay.on(transEndEventName, function() {
				that.$overlay.off(transEndEventName);
				setTimeout(function() {
					that.$overlay.css(&#x27;opacity&#x27;, 0).on(transEndEventName, function() {
						that.$overlay.off(transEndEventName).css({
							clip : &#x27;auto&#x27;,
							zIndex : -1
						});
						// that.$overlay.remove();
						that.$tile.data(&#x27;isExpanded&#x27;, false);
					});
				}, 25);
			});
		} else {
			that.$overlay.css({
				opacity : 0,
				zIndex : -1
			});
			// that.$overlay.remove();
			that.$tile.data(&#x27;isExpanded&#x27;, false);
		}
		// &lt;!--- overlay hide ----&gt;
	};

	Plugin.Layers.InlayRes = function($container, options, uri) {
		this.uri = uri;
		// Get queries
		var queries = []
		var subjectOfQuery = replaceDummy(queryStore.selectSubjectOf, uri);
		var objectOfQuery = replaceDummy(queryStore.selectObjectOf, uri);
		queries.push({
			query : subjectOfQuery,
			type : CONS.CSS_CLASSES.typeClasses.outgoing
		});
		queries.push({
			query : objectOfQuery,
			type : CONS.CSS_CLASSES.typeClasses.incoming
		});
		Plugin.Layer.call(this, $container, options, queries);
	};

	// pseudo class inheritance
	Plugin.Layers.InlayRes.prototype = Object.create(Plugin.Layer.prototype);
	Plugin.Layers.InlayRes.prototype.constructor = Plugin.Layers.Res;

	Plugin.Layers.InlayRes.prototype.loadByRemote = function() {
		print(&quot;loadrem&quot;);
		var that = this;
		var remoteSubjectOf = replaceDummy(queryStore.remoteSubjectOf, that.uri) + &quot; LIMIT &quot;
				+ that.options.remoteOptions.remoteLimit;
		var remoteObjectOf = replaceDummy(queryStore.remoteObjectOf, that.uri) + &quot; LIMIT &quot;
				+ that.options.remoteOptions.remoteLimit;

		// multiplactor 2 is num of queries
		var remoteToDo = remoteDataLoader.backends.length * 2;
		var remoteDoneCount = 0;
		remoteDataLoader.loadingDone.attach(new Plugin.Listener(function(e, query) {
			if (query === remoteSubjectOf || query === remoteObjectOf) {
				remoteDoneCount++;
				print(&quot;remoteDoneCount &quot; + remoteDoneCount);
				that.update();
				if (remoteDoneCount === remoteToDo) {
					remoteDataLoader.loadingDone.dettach(this);
				}
			}
		}));

		// remote needed?
		remoteDataLoader.insertByQuery(remoteSubjectOf);
		remoteDataLoader.insertByQuery(remoteObjectOf);
	};

	Plugin.Layers.InlayRes.prototype._addOverlay = function() {
		var overlayContentAddedDfd = $.Deferred();
		this.$overlay = this.$parent;
		overlayContentAddedDfd.resolve();
		return overlayContentAddedDfd.promise();
	};

	Plugin.Layers.InlayRes.prototype._addBackgroundColor = function() {

	};

	Plugin.Layers.InlayRes.prototype._addOverlayContent = function() {
		var overlayContentAddedDfd = $.Deferred();
		this.$content = $(&quot;&lt;div class=&quot; + CONS.CSS_CLASSES.overlayContent + &quot;&gt;&lt;/div&gt;&quot;);
		this.$overlay.append(this.$content);
		overlayContentAddedDfd.resolve();
		return overlayContentAddedDfd.promise();
	};

	Plugin.Layers.InlayRes.prototype.open = function() {
		this.openEvent.notify();
	};

	Plugin.Layers.InlayRes.prototype.show = function() {
		this.$overlay.css({
			position : &quot;static&quot;,
			opacity : 1,
			pointerEvents : &#x27;auto&#x27;
		});
	};

	Plugin.Layers.InlayRes.prototype.hide = function() {
		this.$overlay.css({
			opacity : 0
		});
	};

	// ========================= bSynopsis: LiteralNodeLayer Class
	/**
	 * Initialization view of the plugin
	 * 
	 * @class Plugin.Layers.Literal
	 * @extends Plugin.Layer
	 * @constructor
	 * @param {jQuery}
	 *           $container Container of the initialization view
	 * @param {Object}
	 *           options Options object
	 * @param {Plugin}
	 *           plugin The parent plugin of the initialization view
	 */
	Plugin.Layers.Literal = function($container, options, $tile) {
		this.$tile = $tile;
		this.node = $tile.data(&quot;node&quot;);

		// Get queries
		var queries = []
		var literalIsObjectOf = replaceDummy(queryStore.literalIsObjectOf,
				this.node.getFComponentOT(&quot;label&quot;).data.value);
		queries.push({
			query : literalIsObjectOf,
			type : CONS.CSS_CLASSES.typeClasses.incoming
		});
		Plugin.Layer.call(this, $container, options, queries);
	};

	// pseudo class inheritance
	Plugin.Layers.Literal.prototype = Object.create(Plugin.Layer.prototype);
	Plugin.Layers.Literal.prototype.constructor = Plugin.Layers.Literal;

	Plugin.Layers.Literal.prototype._addOverlayContent = function() {
		return Plugin.Layers.Res.prototype._addOverlayContent.call(this);
	};

	Plugin.Layers.Literal.prototype._addBackgroundColor = function() {
		Plugin.Layers.Res.prototype._addBackgroundColor.call(this);
	};

	/**
	 * Load children by remote service
	 * 
	 * @method loadByRemote
	 */
	Plugin.Layers.Literal.prototype.loadByRemote = function() {

		var that = this;
		// Get items who are in a relation to
		// current item
		var remoteLiteralIsObjectOf = replaceDummy(queryStore.remoteLiteralIsObjectOf, that.node
				.getFComponentOT(&quot;value&quot;));

		// remote needed?
		remoteDataLoader.insertByQuery(remoteLiteralIsObjectOf + &quot; LIMIT &quot;
				+ that.options.remoteOptions.remoteLimit);
	};

	// ========================= bSynopsis: BlankNodeLayer Class
	/**
	 * Initialization view of the plugin
	 * 
	 * @class Plugin.Layers.Blank
	 * @extends Plugin.Layer
	 * @constructor
	 * @param {jQuery}
	 *           $container Container of the initialization view
	 * @param {Object}
	 *           options Options object
	 * @param {Plugin}
	 *           plugin The parent plugin of the initialization view
	 */
	Plugin.Layers.Blank = function($container, options) {
		// TODO
	};

	// pseudo class inheritance
	Plugin.Layers.Blank.prototype = Object.create(Plugin.Layer.prototype);
	Plugin.Layers.Blank.prototype.constructor = Plugin.Layers.Blank;

	// ========================= bSynopsis: Layers Inlay Class
	/**
	 * Initialization view of the plugin
	 * 
	 * @class Plugin.Layers.Inlay
	 * @extends Plugin.Layer
	 * @constructor
	 * @param {jQuery}
	 *           $container Container of the initialization view
	 * @param {Object}
	 *           options Options object
	 * @param {Plugin}
	 *           plugin The parent plugin of the initialization view
	 */
	Plugin.Layers.Inlay = function($container, options, queries) {
		Plugin.Layer.call(this, $container, options, queries);
	};

	// pseudo class inheritance
	Plugin.Layers.Inlay.prototype = Object.create(Plugin.Layer.prototype);
	Plugin.Layers.Inlay.prototype.constructor = Plugin.Layers.Blank;

	Plugin.Layers.Inlay.prototype._addOverlay = function() {
		var overlayContentAddedDfd = $.Deferred();
		this.$overlay = this.$parent;
		overlayContentAddedDfd.resolve();
		return overlayContentAddedDfd.promise();
	};

	Plugin.Layers.Inlay.prototype._addBackgroundColor = function() {

	};

	Plugin.Layers.Inlay.prototype._addOverlayContent = function() {
		var overlayContentAddedDfd = $.Deferred();
		this.$content = this.$overlay;
		overlayContentAddedDfd.resolve();
		return overlayContentAddedDfd.promise();
	};

	Plugin.Layers.Inlay.prototype.show = function() {
		this.$overlay.css({
			position : &quot;static&quot;,
			opacity : 1,
			pointerEvents : &#x27;auto&#x27;
		});
	};

	Plugin.Layers.Inlay.prototype.hide = function() {
		this.$overlay.css({
			opacity : 0
		});
	};

	// ========================= bSynopsis: Preview Class
	// TODO preview

	// ========================= bSynopsis: TemplatesLoader Class
	/**
	 * Handlebars templates loader to load precompiled or nonprecompiled
	 * templates
	 * 
	 * @class Plugin.TemplatesLoader
	 * @constructor
	 * @param {Deferred
	 *           Object} dfd Deferred Object to resolve when loading is done
	 */
	Plugin.TemplatesLoader = function(dfd) {
		this._templateInitDfd = dfd;
		this._neededTemps = [ &quot;filterOptions&quot;, &quot;sortOptions&quot;, &quot;tileWrapper&quot;, &quot;stdNode&quot;, &quot;groupDropDown&quot;,
				&quot;overlayContent&quot;, &quot;overlayWrapper&quot;, &quot;previewItem&quot;, &quot;timelineWrapper&quot;, &quot;timelineItem&quot; ];

		this._methodsAreLoaded = function(/*
														 * array of templatenames which must
														 * be loaded
														 */) {
			var i = 0, methodName;
			while (arguments[0[i++]] !== undefined) {
				if (typeof templates[arguments[i]] !== &#x27;function&#x27;) {
					return false;
				}
			}
			return true;
		};
	};

	Plugin.TemplatesLoader.prototype._isLoaded = function() {
		if (this._methodsAreLoaded(this._neededTemps)) {
			this._templateInitDfd.resolve();
			return true;
		} else {
			console.log(CONS.MESSAGES.error.template);
			this._templateInitDfd.reject();
			return false;
		}
	};

	Plugin.TemplatesLoader.prototype.getPrecompiledTemplates = function() {
		templates = window[pluginName][&quot;templates&quot;];
		return this._isLoaded();
	};

	// ========================= bSynopsis: RemoteDataLoader Class
	/**
	 * Loader to load remote data from services at the given urls and add them to
	 * the view
	 * 
	 * @class Plugin.RemoteDataLoader
	 * @constructor
	 * @param {Array}
	 *           remoteBackends Array of URLs of SPARQL services to query
	 * @param {Integer}
	 *           pluginID ID of parten plugin
	 */
	Plugin.RemoteDataLoader = function(remoteBackends) {
		this.backends = remoteBackends;
		this.remoteEngine = new RemoteEngine();
		this.loadingStarted = new Plugin.Event(this);
		this.loadingDone = new Plugin.Event(this);
	};

	Plugin.RemoteDataLoader.prototype.addBackend = function(backend) {
		if (!this.backends.find(backend)) {
			this.backends.push(backend);
		}
	};

	Plugin.RemoteDataLoader.prototype.removeBackend = function(backend) {
		var index = this.backends.indexOf(backend);
		if (index &gt; -1) {
			this.backends.splice(index, 1);
		}
	};

	Plugin.RemoteDataLoader.prototype.generateTypeInsertionQuery = function(data) {
		var insertionQuery = &quot;INSERT DATA {&quot;;
		$.each(data, function(i, val) {
			if (val.res &amp;&amp; val.type) {
				insertionQuery += &quot;&lt;&quot; + val.res.value + &quot;&gt; a &quot; + &quot;&lt;&quot; + val.type.value + &quot;&gt;.&quot;;
			}
		});
		insertionQuery += &quot;}&quot;;
		return insertionQuery;
	};

	Plugin.RemoteDataLoader.prototype.generateInsertionQuery = function(data) {
		var insertionQuery = &quot;INSERT DATA {&quot;;
		$.each(data, function(i, val) {
			if (val.subject === undefined) {
				print(&quot;Resultset disfigured.&quot;);
			} else if (val.subject.type === &quot;uri&quot;) {
				insertionQuery += &quot;&lt;&quot; + val.subject.value + &quot;&gt; &quot;;
			} else {
				// TODO BlankNodes
				insertionQuery += &quot;&lt;&quot; + val.subject.value + &quot;&gt; &quot;;
			}
			insertionQuery += &quot;&lt;&quot; + val.predicate.value + &quot;&gt; &quot;;
			if (val.object.type === &quot;uri&quot;) {
				insertionQuery += &quot;&lt;&quot; + val.object.value + &quot;&gt;. &quot;;
			} else if (val.object.type === &quot;literal&quot;) {
				insertionQuery += &#x27;&quot;&#x27; + encodeURIComponent(val.object.value) + &#x27;&quot;. &#x27;;
			} else if (val.object.type === &quot;typed-literal&quot;) {
				// TODO typed-literals
				insertionQuery += &#x27;&quot;&#x27; + encodeURIComponent(val.object.value) + &#x27;&quot;. &#x27;;
			}
			if (val.labelSub) {
				insertionQuery += &#x27;&lt;&#x27; + val.subject.value + &#x27;&gt; rdfs:label &quot;&#x27;
						+ encodeURIComponent(val.labelSub.value) + &#x27;&quot;. &#x27;;
			}
			if (val.labelObj) {
				insertionQuery += &#x27;&lt;&#x27; + val.object.value + &#x27;&gt; rdfs:label &quot;&#x27;
						+ encodeURIComponent(val.labelObj.value) + &#x27;&quot;. &#x27;;
			}
			if (val.labelPred) {
				labelCache.add(encodeURIComponent(val.predicate.value), encodeURIComponent(val.labelPred.value));
			}
		});
		insertionQuery += &quot;}&quot;;
		return insertionQuery;
	};

	Plugin.RemoteDataLoader.prototype._loadRemoteAndInsert = function(query, service, fn, callback) {
		// Execute selection query
		this.remoteEngine.executeQuery(query, service, function(data, success) {

			print(&quot;Remotequery: &#x27;&quot; + query + &quot;&#x27; was a success on &quot; + service + &quot;? \n&quot; + success);
			// Generate insertionQuery out of the resultset.
			if (data &amp;&amp; success) {
				if (data.subject !== undefined) {
					data = [ data ];
				}
				print(&quot;Gives this results: &quot;);
				print(data);
				// Execute insertion
				rdfStore.executeQuery(fn(data), function() {
					if (callback) {
						callback(success);
					}
				});
			} else {
				if (callback) {
					callback(success);
				}
			}
		});
	};

	Plugin.RemoteDataLoader.prototype.executeQuery = function(query, backends, fn) {
		var that = this;
		// Inform the plugin something is loading
		this.loadingStarted.notify();
		var count = -1;
		var backendFlags = [];
		$.each(backends, function(i, val) {
			count++;
			backendFlags[count] = false;
			that._loadRemoteAndInsert(query, val, fn, function(success) {
				backendFlags[count] = true;
				var done = true;
				for (var j = 0; j &lt; backendFlags.length; j++) {
					if (!backendFlags[j]) {
						done = false;
					}
				}
				if (done) {
					that.loadingDone.notify(query);
				}
			});
		});
	};

	Plugin.RemoteDataLoader.prototype.insertByResultset = function(data, callback) {
		var that = this;
		rdfStore.executeQuery(this.generateInsertionQuery(data), function() {
			that.loadingDone.notify(&quot;&quot;);
			if (callback) {
				callback();
			}
		});
	};

	// Inserts Data by querying all services
	Plugin.RemoteDataLoader.prototype.insertByQuery = function(query, backends) {
		if (backends) {
			this.executeQuery(query, backends, this.generateInsertionQuery);
		} else {
			this.executeQuery(query, this.backends, this.generateInsertionQuery);
		}
	};

	Plugin.RemoteDataLoader.prototype.insertTypesByQuery = function(query, backends) {
		if (backends) {
			this.executeQuery(query, backends, this.generateTypeInsertionQuery);
		} else {
			this.executeQuery(query, this.backends, this.generateTypeInsertionQuery);
		}
	};

	// ========================= bSynopsis ===============================

	// Plugin constructor
	/**
	 * Main plugin class of bSynopsis
	 * 
	 * @class Plugin
	 * @constructor
	 * @param {jQuery}
	 *           obj Parent object of the plugin
	 * @param {Object}
	 *           options Options for the plugin
	 */

	// Default options
	/**
	 * Default options for bSynopsis.
	 * 
	 * @property defaults
	 * @type Object
	 */
	var defaults = {
		// TODO workers
		pathToWorkers : &quot;../../workers/&quot;,
		language : &quot;en&quot;,
		/**
		 * Raw RDF data given on plugin startup. This data will be loaded into the
		 * store.
		 * 
		 * @property defaults.data
		 * @type String
		 * @default undefined
		 */
		data : undefined,
		/**
		 * Path to file with Raw RDF data given on plugin startup. This file will
		 * be parsed and loaded into the store.
		 * 
		 * @property defaults.dataLoc
		 * @type String
		 * @default undefined
		 */
		dataLoc : undefined,
		/**
		 * Format of the RDF data which is given on plugin startup.
		 * 
		 * @property defaults.dataFormat
		 * @type String
		 * @default undefined
		 */
		dataFormat : undefined,
		/**
		 * SPARQL resultset bindings which can be used to insert data into the
		 * store on init.
		 * 
		 * @property defaults.sparqlData
		 * @type Object
		 * @default undefined
		 */
		sparqlData : undefined,
		/**
		 * Flag to indicate whether a timeline should be generated and used.
		 * 
		 * @property defaults.generateTimeline
		 * @type Boolean
		 * @default true
		 */
		generateTimeline : true,
		initLayer : {
			name : &quot;Inlay&quot;,
			args : [ [ {
				query : &quot;SELECT ?subject ?label ?description ?type WHERE { ?subject rdfs:label ?label . OPTIONAL { ?subject rdfs:description ?description } . OPTIONAL { ?subject rdfs:comment ?description }. OPTIONAL {?subject rdfs:type ?type}}&quot;
			} ] ]
		// name : &quot;Res&quot;,
		// args : [&quot;http://dbpedia.org/resource/Passau&quot;]
		},
		openDetailOnInit : &quot;&quot;,
		/**
		 * Options for the rdf store class. Uses rdfstore-js
		 * https://github.com/antoniogarrote/rdfstore-js options structure.
		 * 
		 * @property defaults.rdfstoreOptions
		 * @type Object
		 */
		rdfstoreOptions : {
			persistence : true,
			name : &#x27;&#x27;,
			overwrite : true,
			engine : &#x27;&#x27;,
			engineData : {
				mongoDomain : &#x27;&#x27;,
				mongoPort : &#x27;&#x27;,
				mongoOptions : {}
			}
		},
		/**
		 * Options for the bSynopsis view layer.
		 * 
		 * @property defaults.layerOptions
		 * @type Object
		 */
		layerOptions : {
			/**
			 * Filters to be used before node display. Filters only work on single
			 * batches. The batchSize should be chosen big enough if Nodefilters
			 * are to be used. New filters must have a unique identifier.
			 * 
			 * @property defaults.filters
			 * @type Object
			 */
			nodeFilters : {
				/**
				 * Filters blacklisted resources defined by predicate URIs in config
				 * options. Only RegEx allowed.
				 * 
				 * @property defaults.layerOptions.nodeFilters.blacklistPredURI
				 * @type Object
				 */
				blacklistPredURI : {
					fn : function(nodes, config) {
						$.each(nodes, function(i, node) {
							if (node.hasComponentType(&quot;predicate&quot;) &amp;&amp; config) {
								$.each(config, function(j, exp) {
									for (var i = 0; i &lt;= node.componentTypes.predicate; i++) {
										var res = new RegExp(exp).exec(node.components.predicate[i].value);
										if (res !== null) {
											delete nodes[i];
										}
									}
								});
							}
						});
						return nodes;
					},
					config : new Array()
				// Regex to be filtered
				},

				/**
				 * Filters blacklisted resources defined by URIs in config options.
				 * Only RegEx allowed.
				 * 
				 * @property defaults.layerOptions.nodeFilters.blacklistURI
				 * @type Object
				 */
				blacklistURI : {
					fn : function(nodes, config) {
						$.each(nodes, function(i, node) {
							if (node.hasComponentType(&quot;uri&quot;) &amp;&amp; config) {
								$.each(config, function(j, exp) {
									var res = new RegExp(exp).exec(node.components.uri[0]);
									if (res !== null) {
										delete nodes[i];
									}
								});
							}
						});
						return nodes;
					},
					config : new Array()
				// Regex to be filtered
				},

				/**
				 * Merges resNodes describing the same resource (subject or object).
				 * 
				 * @property defaults.layerOptions.nodeFilters.multiResNode
				 * @type Object
				 */
				multiResNode : {
					fn : function(nodes, config) {
						var tempArray = new Array();
						$.each(nodes, function(i, node) {
							if (node.type === &quot;resNode&quot; || node.type === &quot;multiResNode&quot;) {
								if (node.components.uri[0].data in tempArray) {
									tempArray[node.components.uri[0].data].type = &quot;multiResNode&quot;;
									tempArray[node.components.uri[0].data].merge(node);
									delete nodes[i];
								} else {
									tempArray[node.components.uri[0].data] = node;
								}
							}
						});
						return nodes;
					}
				},

				blankNode : {
					fn : function(nodes, config) {
						$.each(nodes, function(i, node) {
							if (node.getType() == CONS.NODE_TYPES.blankNode) {
								// TODO Blanknode
								print(&quot;TODO Blanknode&quot;);
							}
						});
						return nodes;
					},
					config : {

					}
				}

			},
			/**
			 * Define ilters for tiles
			 * 
			 * @property defaults.layerOptions.tileFilters
			 * @type Object
			 */
			tileFilters : {
				/**
				 * Scales tiles
				 * 
				 * @property defaults.layerOptions.tileFilters.scale
				 * @type Object
				 */
				scale : {
					fn : function($tiles, config) {

						$.each($tiles, function(i, tile) {
							var $tile = $(tile);
							var node = $tile.data(&quot;node&quot;);
							var nStyle;
							if (node.style) { // Style passed via
								// node
								nStyle = node.style;
							} else if (config.defaultStyles[node.getType()]) { // Style
								// chosen
								// via node type
								nStyle = config.defaultStyles[node.getType()];
							} else { // Default style
								nStyle = config.defaultStyles[&quot;stdNode&quot;];
							}
							if (typeof nStyle.height != &quot;number&quot;) { // If
								// height of iles should be dynamic (depending on
								// components)
								if (node.dynLayoutFn) { // Function
									// passed
									// via node
									node.dynLayoutFn($tile, node, nStyle, config);
								} else if (config.defaultDynLayoutFns[node.getType()]) { // Function
									// chosen
									// via node
									// type
									config.defaultDynLayoutFns[node.getType()]($tile, node, nStyle, config);
								} else { // Default function
									config.defaultDynLayoutFns[&quot;stdNode&quot;]($tile, node, nStyle, config);
								}
							} else { // If height should be
								// static
								if (node.layoutFn) { // Function
									// passed
									// via node
									node.layoutFn($tile, node, nStyle, config);
								} else if (config.defaultLayoutFns[node.getType()]) { // Function
									// chosen
									// via
									// node
									// type
									config.defaultLayoutFns[node.getType()]($tile, node, nStyle, config);
								} else { // Default function
									config.defaultLayoutFns[&quot;stdNode&quot;]($tile, node, nStyle, config);
								}
							}
						});
						return $tiles;
					},
					config : {
						multiplicator : 1,
						defaultLayoutFns : {
							stdNode : function($tile, node, nStyle, config) {
								var anchorY = $tile.height() + nStyle.topPadding;
								var mult = config.multiplicator;
								$tile.width(nStyle.width * mult);
								var height = nStyle.height * mult;
								$tile.height(height);
								var contentHeight = height - (nStyle.topPadding + nStyle.bottomPadding * mult);
								var temp = 0;
								var cStyles = {};
								$.each(node.components, function(j, componentType) {
									$.each(componentType, function(i, component) {
										var id = component.id;
										if (component.style) {
											cStyles[id] = component.style;
										} else if (config.defaultContentStyles[component.type]) {
											cStyles[id] = config.defaultContentStyles[component.type];
										} else {
											cStyles[id] = config.defaultContentStyles[&quot;stdComponent&quot;];
										}
										if (cStyles[id] &amp;&amp; (!cStyles[id].display || cStyles[id].display != &quot;none&quot;)) {
											temp += cStyles[id].height;
										}
									});
								});
								$.each(node.components, function(j, componentType) {
									$.each(componentType, function(i, component) {
										var id = component.id;
										if (cStyles[id] &amp;&amp; (!cStyles[id].display || cStyles[id].display != &quot;none&quot;)) {
											var cStyle = cStyles[id];
											if (component.layoutFn) {
												anchorY = component.layoutFn($tile, node, nStyle, component, cStyle,
														config, anchorY, contentHeight, temp);
											} else if (config.defaultContentLayoutFns[component.type]) {
												anchorY = config.defaultContentLayoutFns[component.type]($tile, node,
														nStyle, component, cStyle, config, anchorY, contentHeight, temp);
											} else {
												anchorY = config.defaultContentLayoutFns[&quot;stdComponent&quot;]($tile, node,
														nStyle, component, cStyle, config, anchorY, contentHeight, temp);
											}
										}
									});
								});
							}
						},
						defaultDynLayoutFns : {
							stdNode : function($tile, node, nStyle, config) {
								var startY = $tile.height();
								var mult = config.multiplicator;
								var anchorY = startY + (nStyle.topPadding * mult);
								$tile.width(nStyle.width * mult);
								$.each(node.components, function(j, componentType) {
									$.each(componentType, function(i, component) {
										var cStyle;
										if (component.style) {
											cStyle = component.style;
										} else if (config.defaultContentStyles[component.type]) {
											cStyle = config.defaultContentStyles[component.type];
										} else {
											cStyle = config.defaultContentStyles[&quot;stdComponent&quot;];
										}
										if (cStyle &amp;&amp; (!cStyle.display || cStyle.display != &quot;none&quot;)) {
											if (component.dynLayoutFn) {
												anchorY = component.dynLayoutFn($tile, node, nStyle, component, cStyle,
														config, anchorY);
											} else if (config.defaultContentDynLayoutFns[component.type]) {
												anchorY = config.defaultContentDynLayoutFns[component.type]($tile, node,
														nStyle, component, cStyle, config, anchorY);
											} else {
												anchorY = config.defaultContentDynLayoutFns[&quot;stdComponent&quot;]($tile, node,
														nStyle, component, cStyle, config, anchorY);
											}
										}
									});
								});
								$tile.height(anchorY + (nStyle.bottomPadding * mult) - startY);
							}
						},
						defaultContentLayoutFns : {
							predicate : function($tile, node, nStyle, component, cStyle, config, anchorY,
									contentHeight, divisor) {
								var $component = $tile.find(UTIL.toClassSelector(component.id));
								print(UTIL.toClassSelector(component.id));
								console.log($component)
								var mult = config.multiplicator;
								var cHeight = contentHeight * (cStyle.height / divisor) - nStyle.spacing * mult;
								var cWidth = ((nStyle.width - nStyle.leftPadding - nStyle.rightPadding) * mult);
								$component.height(cHeight);
								$component.width(cWidth);
								$component.css(&quot;top&quot;, anchorY);
								$component.css(&quot;left&quot;, nStyle.leftPadding);
								anchorY += (cHeight + nStyle.spacing * mult);
								$component.children().height(cHeight);
								var $typeImage = $tile.find(UTIL.toSelector(CONS.CSS_CLASSES.tileClasses.typeImage));
								var $predicate = $tile.find(UTIL.toSelector(CONS.CSS_CLASSES.tileClasses.predicate));
								var $predicateLabel = $tile.find(UTIL
										.toSelector(CONS.CSS_CLASSES.tileClasses.predicateLabel));
								var imageWidth = cWidth * 0.2;
								$typeImage.height(&quot;auto&quot;);
								$typeImage.width(imageWidth);
								$predicateLabel.css(&quot;left&quot;, imageWidth);
								$predicateLabel.width(cWidth - imageWidth);
								$predicate.width(cWidth);
								return anchorY;
							},
							stdComponent : function($tile, node, nStyle, component, cStyle, config, anchorY,
									contentHeight, divisor) {
								var $component = $tile.find(UTIL.toClassSelector(component.id));
								var mult = config.multiplicator;
								var cHeight = contentHeight * (cStyle.height / divisor) - nStyle.spacing * mult;
								$component.width((nStyle.width - nStyle.leftPadding - nStyle.rightPadding) * mult);
								$component.height(cHeight);
								$component.css(&quot;top&quot;, anchorY);
								$component.css(&quot;left&quot;, nStyle.leftPadding);
								anchorY += (cHeight + nStyle.spacing * mult);
								return anchorY;
							}
						},
						defaultContentDynLayoutFns : {
							predicate : function($tile, node, nStyle, component, cStyle, config, anchorY) {
								var $component = $tile.find(UTIL.toClassSelector(component.id));
								var mult = config.multiplicator;
								var cHeight = cStyle.height * mult;
								var cWidth = (nStyle.width - nStyle.leftPadding - nStyle.rightPadding) * mult;
								$component.height(cHeight);
								$component.width(cWidth);
								$component.css(&quot;top&quot;, anchorY);
								$component.css(&quot;left&quot;, nStyle.leftPadding);
								anchorY += (cHeight + nStyle.spacing * mult);
								$component.children().height(cHeight);
								var $typeImage = $tile.find(UTIL.toSelector(CONS.CSS_CLASSES.tileClasses.typeImage));
								var $predicate = $tile.find(UTIL.toSelector(CONS.CSS_CLASSES.tileClasses.predicate));
								var $predicateLabel = $tile.find(UTIL
										.toSelector(CONS.CSS_CLASSES.tileClasses.predicateLabel));
								var imageWidth = cWidth * 0.2;
								$typeImage.height(&quot;auto&quot;);
								$typeImage.width(imageWidth);
								$predicateLabel.css(&quot;left&quot;, imageWidth);
								$predicateLabel.width(cWidth - imageWidth);
								$predicate.width(cWidth);
								return anchorY;
							},
							stdComponent : function($tile, node, nStyle, component, cStyle, config, anchorY) {
								var $component = $tile.find(UTIL.toClassSelector(component.id));
								var mult = config.multiplicator;
								$component.width((nStyle.width - nStyle.leftPadding - nStyle.rightPadding) * mult);
								$component.height(cStyle.height * mult);
								$component.css(&quot;top&quot;, anchorY);
								$component.css(&quot;left&quot;, nStyle.leftPadding);
								anchorY += ((cStyle.height + nStyle.spacing) * mult);
								return anchorY;
							}
						},
						defaultStyles : {
							/**
							 * Styles of literal items.
							 * 
							 * @property defaults.layerOptions.tileFilters.scale.config.defaultStyles.literal
							 * @type Object
							 */
							// literal : {
							/**
							 * Width of literal items.
							 * 
							 * @property defaults.layerOptions.tileFilters.scale.config.defaultStyles.literal.width
							 * @type Integer
							 * @default 200
							 */
							// width : 200,
							/**
							 * Height of literal items.
							 * 
							 * @property defaults.layerOptions.tileFilters.scale.config.defaultStyles.literal.height
							 * @type Integer
							 * @default 100
							 */
							// height : 100
							// },
							/**
							 * Styles of res nodes.
							 * 
							 * @property defaults.layerOptions.tileFilters.scale.config.defaultStyles.stdNode
							 * @type Object
							 */
							stdNode : {
								/**
								 * Width of items.
								 * 
								 * @property defaults.layerOptions.tileFilters.scale.config.defaultStyles.stdNode.width
								 * @type Integer
								 * @default 200
								 */
								width : 200,
								/**
								 * Height of items.
								 * 
								 * @property defaults.layerOptions.tileFilters.scale.config.defaultStyles.stdNode.width
								 * @type Integer or String
								 * @default 200 / dynamic
								 */
								height : &quot;dynamic&quot;,
								topPadding : 10,
								leftPadding : 10,
								rightPadding : 10,
								bottomPadding : 10,
								spacing : 5
							}
						},
						defaultContentStyles : {
							predicate : {
								height : 20
							},
							label : {
								height : 60
							},
							stdComponent : {
								height : 40
							}
						}
					}
				},

				/**
				 * Scales text of tiles
				 * 
				 * @property defaults.layerOptions.tileFilters.textScale
				 * @type Object
				 */
				textScale : {
					fn : function($tiles, config, layer) {
						// On layout done event
						// TODO fix if hidden
						layer.view.layoutEngine.partialDoneEvent.attach(new Plugin.Listener(function(e,
								newInsertions) {
							newInsertions = $(newInsertions);
							if (newInsertions) {
								var startTime = new Date().getTime();
								var $fitHere = newInsertions.find(UTIL.toSelector(CONS.CSS_CLASSES.textScale));
								$fitHere.textfill(config.maxFontPixels, config.minFontPixels, function($parent) {
									$parent.css({
										&quot;overflow-y&quot; : &quot;auto&quot;,
										&quot;word-wrap&quot; : &quot;break-word&quot;
									});
								});
								$fitHere.removeClass(CONS.CSS_CLASSES.textScale);
								$fitHere.addClass(CONS.CSS_CLASSES.textScaleDone);
								print(&quot;Event textScaleEvent done after: &quot; + (new Date().getTime() - startTime)
										+ &quot; milisec&quot;);
							}
						}));
						return $tiles;
					},
					config : {
						maxFontPixels : 80,
						minFontPixels : 12
					}
				},

				/**
				 * Sets backgroundColor for tiles
				 * 
				 * @property defaults.layerOptions.tileFilters.backgroundColor
				 * @type Object
				 */
				backgroundColor : {
					fn : function($tiles, config) {
						var colorizeFn = function(res, $tile) {
							var color, rdfsColor;
							$.each(res, function(i, val) {
								var currentUri = val.type.value;
								if (currentUri.indexOf(namespaces.rdfs) !== -1
										|| currentUri.indexOf(namespaces.owl) !== -1) {
									if (!color) {
										if (rdfsColor) {
											var scale = chroma.scale(
													[ rdfsColor.hex(), &quot;#&quot; + md5(currentUri).substring(0, 6) ])
													.mode(&#x27;lch&#x27;);
											rdfsColor = chroma(scale(0.5).hex());
										} else {
											rdfsColor = chroma(&quot;#&quot; + md5(currentUri).substring(0, 6));
										}
									}
								} else {
									if (color) {
										var scale = chroma
												.scale([ color.hex(), &quot;#&quot; + md5(currentUri).substring(0, 6) ])
												.mode(&#x27;lch&#x27;);
										color = chroma(scale(0.5).hex());
									} else {
										color = chroma(&quot;#&quot; + md5(currentUri).substring(0, 6));
									}
								}
							});
							if (color) {
								// TODO
								// Dirty brightness fix;
								if (color._rgb[0] &gt; 200 &amp;&amp; color._rgb[1] &gt; 200 &amp;&amp; color._rgb[2] &gt; 200) {
									color._rgb[0] = color._rgb[0] - 50;
									color._rgb[1] = color._rgb[1] - 50;
									color._rgb[2] = color._rgb[2] - 50;
								}
								$tile.css(&quot;background-color&quot;, color);
							} else if (rdfsColor) {
								// TODO
								// Dirty brightness fix;
								if (rdfsColor._rgb[0] &gt; 200 &amp;&amp; rdfsColor._rgb[1] &gt; 200 &amp;&amp; rdfsColor._rgb[2] &gt; 200) {
									rdfsColor._rgb[0] = rdfsColor._rgb[0] - 50;
									rdfsColor._rgb[1] = rdfsColor._rgb[1] - 50;
									rdfsColor._rgb[2] = rdfsColor._rgb[2] - 50;
								}
								$tile.css(&quot;background-color&quot;, rdfsColor);
							}
						};
						var counter = 0;
						var cbTiles = [];
						var batches = [];
						var queryStart = &quot;SELECT DISTINCT ?res ?type WHERE { VALUES ?res {&quot;
						var remoteQuery = &quot;SELECT DISTINCT ?res ?type WHERE { VALUES ?res {&quot;
						batches.push({
							count : 0,
							cbTiles : [],
							query : queryStart
						});
						$.each($tiles, function(i, tile) {
							var $tile = $(tile);
							var node = $tile.data(&quot;node&quot;);
							if (node.getType() === CONS.NODE_TYPES.resNode || node.getType() === &quot;multiResNode&quot;) {
								var uri = node.getFComponentOT(&#x27;uri&#x27;).data;
								var bLeng = batches.length - 1;
								if (batches[bLeng].count &lt; config.batchSize) {
									batches[bLeng].count++;
									batches[bLeng].cbTiles.push($tile);
									batches[bLeng].query += &quot;&lt;&quot; + uri + &quot;&gt;&quot;;
								} else {
									// finish query
									batches[bLeng].query += &quot;} ?res a ?type}&quot;;
									bLeng++;
									batches.push({
										count : 1,
										cbTiles : [],
										query : queryStart
									});
									batches[bLeng].cbTiles.push($tile);
									batches[bLeng].query += &quot;&lt;&quot; + uri + &quot;&gt;&quot;;
								}
							} else {
								counter++;
								var colorArray, color;
								if (node.style &amp;&amp; node.style.bgColors) {
									colorArray = node.style.bgColors;
									color = new RGBColor(colorArray[counter % colorArray.length]);
								} else if (config.defaultStyles[node.getType()]) {
									colorArray = config.defaultStyles[node.getType()].bgColors;
									color = new RGBColor(colorArray[counter % colorArray.length]);
								}
								if (color) {
									$tile.css(&quot;background-color&quot;, &quot;rgba(&quot; + color.r + &quot;, &quot; + color.g + &quot;, &quot; + color.b
											+ &quot; ,1)&quot;);
								}
							}
						});

						// finish last query
						batches[batches.length - 1].query += &quot;} ?res a ?type}&quot;;

						// For each batch
						if (batches[0].count &gt; 0) {
							$.each(batches, function(i, batch) {
								remoteDataLoader.insertTypesByQuery(batch.query);
								remoteDataLoader.loadingDone.attach(new Plugin.Listener(function(e, query) {
									if (query == batch.query) {
										remoteDataLoader.loadingDone.dettach(this);
										$.each(batch.cbTiles, function(j, tile) {
											var $tile = $(tile);
											var node = $tile.data(&quot;node&quot;);
											var uri = node.getFComponentOT(&#x27;uri&#x27;).data;
											var localQuery = replaceDummy(queryStore.typeQuery, uri);
											rdfStore.executeQuery(localQuery, function(res) {
												colorizeFn(res, $tile);
											});
										});
									}
								}));
							});
						}
						return $tiles;
					},
					config : {
						batchSize : 100,
						defaultStyles : {
							literal : {
								/**
								 * Color of literal items.
								 * 
								 * @property defaults.layerOptions.tileFilters.backgroundColor.config.defaultStyles.literal.bgColors
								 * @type Array
								 * @default [ &#x27;#777777&#x27; ]
								 */
								bgColors : [ &#x27;#555555&#x27; ]
							},
							blankNode : {
								bgColors : [ &#x27;#999999&#x27; ]
							}
						// ,
						// stdNode : {
						// /**
						// * Colors of items.
						// *
						// * @property
						// defaults.layerOptions.tileFilters.backgroundColor.config.defaultStyles.stdNode.bgColors
						// * @type Array
						// * @default [ &#x27;#e2674a&#x27;, &#x27;#99CC99&#x27;, &#x27;#3399CC&#x27;,
						// * &#x27;#33CCCC&#x27;, &#x27;#996699&#x27;, &#x27;#C24747&#x27;, &#x27;#FFCC66&#x27;,
						// * &#x27;#669999&#x27;, &#x27;#CC6699&#x27;, &#x27;#339966&#x27;, &#x27;#666699&#x27; ]
						// */
						// bgColors : [ &#x27;#e2674a&#x27;, &#x27;#99CC99&#x27;, &#x27;#3399CC&#x27;, &#x27;#33CCCC&#x27;,
						// &#x27;#996699&#x27;,
						// &#x27;#C24747&#x27;,
						// &#x27;#FFCC66&#x27;, &#x27;#669999&#x27;, &#x27;#CC6699&#x27;, &#x27;#339966&#x27;, &#x27;#666699&#x27; ]
						// }
						}
					}
				},

				/**
				 * Loads background images
				 * 
				 * @property defaults.layerOptions.tileFilters.backgroundImg
				 * @type Object
				 */
				backgroundImg : {
					fn : function($tiles, config) {
						// TODO image path?
						return $tiles;
						$.each($tiles, function(i, tile) {
							var $tile = $(tile);
							var node = $tile.data(&quot;node&quot;), image_url = &quot;&quot;;
							switch (node.getType()) {
							case CONS.NODE_TYPES.resNode:
								image_url = node.getFComponentOT(&quot;uri&quot;).data;
								break;

							case CONS.NODE_TYPES.literal:
								image_url = node.getFComponentOT(&quot;label&quot;).data.value;
								break;
							}
							var tmpArray = image_url.replace(&quot;&gt;&quot;, &quot;&quot;).split(&quot;.&quot;);
							image_url.replace(&quot;&lt;&quot;, &quot;&quot;);
							switch (tmpArray[tmpArray.length - 1]) {
							case &quot;png&quot;:
							case &quot;jpeg&quot;:
							case &quot;svg&quot;:
							case &quot;jpg&quot;:

								if (image_url) {
									var $img = $(&#x27;&lt;img src=&quot;en.wikipedia.org/wiki/File:&#x27; + image_url + &#x27;&quot;&gt;&#x27;);
									$img.load(function() {
										var width = $img.width();
										var height = $img.height();
										var ratio = width / height;
										var tile_width = $tile.width();
										var tile_height = $tile.height();
										var tile_ration = tile_width / tile_height;
										var actual_width = 0;

										if (tile_ration &gt; ratio) {
											actual_width = tile_width / ratio;
											$img.width(tile_width / ratio);
											$img.height(tile_height);
										} else {
											$img.width(actual_width);
											$img.height(tile_width * ratio);
										}
										$img.css({
											&quot;left&quot; : (tile_width - actual_width) / 2,
											&quot;opacity&quot; : config.opacity,
											&quot;position&quot; : &quot;absolute&quot;
										});
									});
									$tile.prepend($img);
								}
								break;
							}
						});
						return $tiles;
					},
					config : {
						opacity : 0.5
					}
				},

				/**
				 * Enables mouseover for URIs
				 * 
				 * @property defaults.layerOptions.tileFilters.predicateLabel
				 * @type Object
				 */
				predicateLabel : {
					fn : function($tiles) {
						$.each($tiles, function(i, tile) {
							var $tile = $(tile);
							var $predicate = $tile.find(UTIL.toSelector(CONS.CSS_CLASSES.tileClasses.predicate));
							var $typeImage = $tile.find(UTIL.toSelector(CONS.CSS_CLASSES.tileClasses.typeImage));
							var $predicateLabel = $tile.find(UTIL
									.toSelector(CONS.CSS_CLASSES.tileClasses.predicateLabel));

							// Show full URI on mouse right
							// click / prevent default
							// contextmenu
							$tile.get()[0].addEventListener(&#x27;contextmenu&#x27;, function(ev) {
								ev.preventDefault();
								if ($predicate.css(&quot;visibility&quot;) !== &quot;visible&quot;) {
									$predicate.css(&quot;visibility&quot;, &quot;visible&quot;);
									$typeImage.css(&quot;visibility&quot;, &quot;hidden&quot;);
									$predicateLabel.css(&quot;visibility&quot;, &quot;hidden&quot;);

								} else {
									$predicate.css(&quot;visibility&quot;, &quot;hidden&quot;);
									$typeImage.css(&quot;visibility&quot;, &quot;visible&quot;);
									$predicateLabel.css(&quot;visibility&quot;, &quot;visible&quot;);
								}
								return false;
							}, false);
						});
						return $tiles;
					}
				},

				/**
				 * Initializes the browsability of tiles
				 * 
				 * @property defaults.layerOptions.tileFilters.browsablity
				 * @type Object
				 */
				browsablity : {
					fn : function($tiles, config, layer) {
						$.each($tiles, function(i, tile) {
							var $tile = $(tile);
							var node = $tile.data(&quot;node&quot;);
							var nodeType = node.getType();
							var layerGenFn;
							var layerOptionsFn;
							var onInitFn;
							if (node.browsablity) {
								if (node.browsablity.layerGenFn) {
									layerGenFn = node.browsablity.layerGenFn;
								}
								if (node.browsablity.layerOptionsFn) {
									layerOptionsFn = node.browsablity.layerOptionsFn;
								}
								if (node.browsablity.onInitFn) {
									layerOptionsFn = node.browsablity.onInitFn;
								}
							} else if (nodeType in config.types) {
								if (config.types[nodeType].layerGenFn) {
									layerGenFn = config.types[nodeType].layerGenFn;
								}
								if (config.types[nodeType].layerOptionsFn) {
									layerOptionsFn = config.types[nodeType].layerOptionsFn;
								}
								if (config.types[nodeType].onInitFn) {
									layerOptionsFn = config.types[nodeType].onInitFn;
								}
							}
							if (!layerGenFn) {
								layerGenFn = config.defaultFns.layerGenFn;
							}
							if (!layerOptionsFn) {
								layerOptionsFn = config.defaultFns.layerOptionsFn;
							}
							if (!onInitFn) {
								onInitFn = config.defaultFns.onInitFn;
							}
							$tile.click(
							// Save fns in function
							function() {
								return function() {
									$tile.data(&#x27;isExpanded&#x27;, true);
									var newLayer = layerGenFn(node, $tile, layer.$parent,
											layerOptionsFn(layer.options));
									if (newLayer) {
										newLayer.initSwitch.attach(new Plugin.Listener(function() {
											return function(sender) {
												onInitFn(sender, layer);
											}
										}(onInitFn, layer)));
									}
								}(layerGenFn, layerOptionsFn, onInitFn, layer);
							});
						});
						return $tiles;
					},
					config : {
						types : {
							blankNode : {
								layerGenFn : function(node, $tile, $parent, newLayerOptions) {
									// TODO
								}
							},
							stdNode : {
								layerGenFn : function(node, $tile, $parent, newLayerOptions) {
									return new Plugin.Layers.Res($parent, newLayerOptions, $tile);
								}
							},
							literal : {
								layerGenFn : function(node, $tile, $parent, newLayerOptions) {
									return new Plugin.Layers.Literal($parent, newLayerOptions, $tile);
								}
							}
						},
						defaultFns : {
							layerOptionsFn : function(options) {
								return $.extend(true, {}, options, {
									viewOptions : {
										filterBy : [ {
											value : &quot;*&quot;,
											label : &quot;showAll&quot;
										}, {
											value : CONS.CSS_CLASSES.typeClasses.incoming,
											label : &quot;in&quot;
										}, {
											value : CONS.CSS_CLASSES.typeClasses.outgoing,
											label : &quot;out&quot;
										} ]
									}
								});
							},
							layerGenFn : function(node, $tile, $parent, newLayerOptions) {
								return new Plugin.Layers.Res($parent, newLayerOptions, $tile);
							},
							onInitFn : function(sender, layer) {
								layer.closeEvent.attach(new Plugin.Listener(function(sender) {
									sender.filterEvent.notify({
										&quot;action&quot; : &quot;removeLayer&quot;
									});
								}));
								layer.filterEvent.notify({
									&quot;action&quot; : &quot;addLayer&quot;,
									&quot;args&quot; : sender
								});
							}
						}
					}
				},
				weight : {
					fn : function($tiles, config) {
						$.each($tiles, function(i, tile) {
							var $tile = $(tile);
							var node = $tile.data(&quot;node&quot;);
							node.weight = 0;
							$.each(config, function(ruleName, rule) {
								node.weight = rule.fn(node, rule.data);
							});
							$tile.data(&quot;node&quot;, node);
						});
						return $tiles;
					},
					config : {
						uriRule : {
							fn : function(node, data) {
								var uri = node.getFComponentOT(&quot;uri&quot;).data;
								var weight = node.weight;
								if (uri) {
									$.each(data, function(str, value) {
										if (uri.indexOf(str) !== -1) {
											weight += value * Math.random();
										}
									});
								}
								return weight;
							},
							data : {
								&#x27;http://www.w3.org/2000/01/rdf-schema#&#x27; : -1,
								&#x27;http://www.w3.org/2002/07/owl#&#x27; : -1
							}
						},
						predicateRule : {
							fn : function(node, data) {
								var weight = node.weight;
								node.forEachComponentType(&quot;predicate&quot;, function() {
									weight += data.val * Math.random();
								});
								return weight;
							},
							data : {
								val : 0.5
							}
						},
						templateRule : {
							fn : function(node, data) {
								var tempalteID = node.useTemplateID;
								var weight = node.weight;
								if (tempalteID) {
									$.each(data, function(str, value) {
										if (tempalteID === str) {
											weight += value * (Math.random() + 0.1);
										}
									});
								}
								return weight;
							},
							data : {
								&#x27;maps&#x27; : 2,
								&#x27;cityChart&#x27; : 1
							}
						}

					}
				}
			},
			/**
			 * Flag to indicate whether the sort interface should be generated.
			 * 
			 * @property defaults.layerOptions.generateSortOptions
			 * @type Boolean
			 * @default true
			 */
			generateSortOptions : true,
			/**
			 * Flag to indicate whether previews should be used.
			 * 
			 * @property defaults.layerOptions.generateSortOptions
			 * @type Boolean
			 * @default true
			 */
			usePreviews : false,
			/**
			 * Flag to indicate which kind of previews should be used. Possible
			 * options are
			 * 
			 * @property defaults.layerOptions.previewAsOverlay
			 * @type Boolean
			 * @default Overlay
			 */
			previewAsOverlay : true,
			/**
			 * Flag to indicate whether the filter interface should be generated.
			 * 
			 * @property defaults.layerOptions.generateFilterOptions
			 * @type Boolean
			 * @default true
			 */
			generateFilterOptions : true,

			/**
			 * Options for the model holding node results.
			 * 
			 * @property defaults.layerOptions.modelOptions
			 * @type Object
			 */
			modelOptions : {
				/**
				 * Batch size of items which can be loaded simultaniosly in the
				 * view. Filters only work on single batches. The batchSize should
				 * be chosen big enough if Nodefilters are to be used.
				 * 
				 * @property defaults.layerOptions.modelOptions.batchSize
				 * @type Integer
				 * @default 2000
				 */
				batchSize : 2000

			},
			/**
			 * Options for remote loading of data.
			 * 
			 * @property defaults.layerOptions.remoteOptions
			 * @type Object
			 */
			remoteOptions : {
				/**
				 * Default remote load query. Used on insertRemoteData() if no query
				 * parameter is given.
				 * 
				 * @property defaults.layerOptions.remoteOptions.defaultInitRemoteQuery
				 * @type String
				 * @default &quot;SELECT ?subject ?predicate ?object { VALUES ?subject {
				 *          &lt;http://dbpedia.org/resource/Berlin&gt;
				 *          &lt;http://dbpedia.org/resource/Passau&gt;
				 *          &lt;http://dbpedia.org/resource/Munich&gt;
				 *          &lt;http://dbpedia.org/resource/Frankfurt&gt; } VALUES
				 *          ?predicate { rdfs:label } ?subject ?predicate ?object.
				 *          FILTER (lang(?object) = &#x27;en&#x27;) } LIMIT 150&quot;
				 */
				defaultInitRemoteQuery : &quot;SELECT ?subject ?predicate ?object { VALUES ?subject { &lt;http://dbpedia.org/resource/Berlin&gt; &lt;http://dbpedia.org/resource/Passau&gt; &lt;http://dbpedia.org/resource/Munich&gt; &lt;http://dbpedia.org/resource/Frankfurt&gt; } VALUES ?predicate { rdfs:label } ?subject ?predicate ?object. FILTER (lang(?object) = &#x27;en&#x27;) } LIMIT 150&quot;,
				/**
				 * Backend services to query on remote loading.
				 * 
				 * @property defaults.layerOptions.remoteOptions.remoteBackends
				 * @type Array
				 * @default [&quot;http://zaire.dimis.fim.uni-passau.de:8080/bigdata/sparql&quot;]
				 */
				remoteBackends : [ &quot;http://dbpedia.org/sparql&quot; ],

				/**
				 * Limit for items loaded by a single remote load.
				 * 
				 * @property defaults.layerOptions.remoteOptions.remoteLimit
				 * @type Integer } *
				 * @default 1000
				 */
				remoteLimit : 1000,
				/**
				 * Flag to indicate whether automatic remote load on detail view
				 * should be done.
				 * 
				 * @property defaults.layerOptions.remoteOptions.remoteDynamically
				 * @type Boolean
				 * @default true
				 */
				remoteDynamically : true,
				waitForRemote : false,
				/**
				 * Remote backends to query for predicate label information.
				 * 
				 * @property defaults.layerOptions.remoteOptions.remoteLabelBackend
				 * @type Array
				 * @default [&quot;http://zaire.dimis.fim.uni-passau.de:8080/bigdata/sparql&quot;,&quot;http://dbpedia.org/sparql&quot;]
				 */
				remoteLabelBackend : [ &quot;http://zaire.dimis.fim.uni-passau.de:8080/bigdata/sparql&quot;,
						&quot;http://dbpedia.org/sparql&quot; ],
				/**
				 * Flag to indicate whether remote label information should be
				 * loaded if needed.
				 * 
				 * @property defaults.layerOptions.remoteOptions.remoteLabels
				 * @type Boolean
				 * @default true
				 */
				remoteLabels : true
			},
			/**
			 * Options for the bSynopsis views.
			 * 
			 * @property defaults.layerOptions.viewOptions
			 * @type Object
			 */
			viewOptions : {
				sortFns : {
					weight : function(elem) {
						var $elem = $(elem);
						var node = $elem.data(&quot;node&quot;);
						var weight = node.weight;
						if (!isUndefinedOrNull(weight)) {
							return -1 * weight;
						} else {
							return 0;
						}
					},
					alphabetical : function(elem) {
						var $elem = $(elem);
						var label = $elem.find(UTIL.toSelector(CONS.CSS_CLASSES.tileClasses.label)), itemText = label.length ? label
								: $elem;
						return itemText.text();
					}
				},

				/**
				 * Default filter to be added to the filter interface.
				 * 
				 * @property defaults.layerOptions.viewOptions.filterBy
				 * @type Object
				 * @default [ { value : &quot;*&quot;, label : &quot;showAll&quot; } ]
				 */
				filterBy : [ {
					value : &quot;*&quot;,
					label : &quot;showAll&quot;
				} ],

				/**
				 * Options for the layoutEngine. Uses isotope
				 * http://isotope.metafizzy.co/ options structure.
				 * 
				 * @property defaults.layerOptions.viewOptions.layoutEngineOptions
				 * @type Object
				 */
				layoutEngineOptions : {
					/**
					 * Flag to indicate whether the filter should use regular
					 * expressions if the chosen layout supports it.
					 * 
					 * @property defaults.layerOptions.viewOptions.layoutEngineOptions.supportRegExpFilter
					 * @type Boolean
					 * @default true
					 */
					supportRegExpFilter : true,
					useEngine : &quot;isotope&quot;,
					clusterSize : 10,
					clusterWait : 10
					,
					shuffle : {
						filterFns : {
							&quot;contains&quot; : function($el, shuffle) {
								// Only search elements in the current group
								if (shuffle.group !== &#x27;all&#x27; &amp;&amp; $.inArray(shuffle.group, $el.data(&#x27;groups&#x27;)) === -1) {
									return false;
								}
								var text = $.trim($el.text()).toLowerCase();
								return text.indexOf(selector) !== -1;
							},
							&quot;class&quot; : function($el, shuffle) {
								return $el.hasClass(selector);
							}
						},
						options : {
							itemSelector : UTIL.toSelector(CONS.CSS_CLASSES.tileClasses.tile),
							columnWidth : 1,
							sequentialFadeDelay : 0,
							supported : false
						}
					}
					,
					isotope : {
						options : {
							itemSelector : UTIL.toSelector(CONS.CSS_CLASSES.tileClasses.tile),
							transitionDuration : 0,
							layoutMode : &#x27;packery&#x27;,
							sortBy : &#x27;weight&#x27;,
							getSortData : {
								weight : function(elem) {
									var $elem = $(elem);
									var node = $elem.data(&quot;node&quot;);
									var weight = node.weight;
									if (!isUndefinedOrNull(weight)) {
										return -1 * weight;
									} else {
										return 0;
									}
								},
								alphabetical : function(elem) {
									var $elem = $(elem);
									var label = $elem.find(UTIL.toSelector(CONS.CSS_CLASSES.tileClasses.label)), itemText = label.length ? label
											: $elem;
									return itemText.text();
								}
							}
						}
					}
				}
			}
		}
	};

	function Plugin(obj, options) {
		// &lt;---- private utility functions ----&gt;
		/**
		 * Uses $.proxy() to overwrite the context of a given function with the
		 * widget context.
		 * 
		 * @private
		 * @method _selfProxy
		 * @param {Function}
		 *           fn Function to modifie
		 * @return function with modified context
		 */
		this._selfProxy = function(fn) {
			return $.proxy(fn, this);
		};
		// &lt;!--- instance private utility functions ----&gt;

		this.pluginID = generateId();

		this._extendedLayers = {};
		this._topLayer;

		this._$parent = $(obj);
		this.$body = $(&#x27;BODY&#x27;);

		eventManagers[this.pluginID] = new Plugin.EventManager(this._$parent);

		// Give parentobj of the plugin a correspondending plugin class
		this._$parent.addClass(pluginName + &quot;_&quot; + this.pluginID);
		this._$parent.addClass(pluginName);

		// Use $.extend to merge the given plugin options with the defaults
		this.options = $.extend(true, {}, defaults, options);
		this._defaults = defaults;

		this._name = pluginName;

		this._expandedOverlaysCount = 0;

		this.init();
	}

	Plugin.prototype = {
		// &lt;---- private functions ----&gt;

		/**
		 * Initializes the rdf store
		 * 
		 * @private
		 * @method _initRdfStore
		 */
		_initRdfStore : function() {
			var that = this, rdfStoreInitDfd = $.Deferred();
			print(&quot;Init RDFSTORE&quot;);
			if (isUndefinedOrNull(rdfStore)) {
				rdfStore = new Plugin.RdfStore(that.options.rdfstoreOptions, function(store) {
					rdfStoreInitDfd.resolve();
				});
			}
			return rdfStoreInitDfd.promise();
		},
		/**
		 * Initializes the remote data loader
		 * 
		 * @private
		 * @method ;
		 */
		_initRemoteDataLoader : function() {
			var that = this;
			if (isUndefinedOrNull(remoteDataLoader)) {
				remoteDataLoader = new Plugin.RemoteDataLoader(
						this.options.layerOptions.remoteOptions.remoteBackends);
			} else {
				$.each(this.options.layerOptions.remoteOptions.remoteBackends, function(i, val) {
					remoteDataLoader.addBackend(val);
				});
			}
			// TODO update on datainsertion
			// remoteDataLoader.loadingDone.attach(new Plugin.Listener(function() {
			// that.updateTopLayer();
			// }));
		},
		/**
		 * Initializes the templating
		 * 
		 * @private
		 * @method _initTemplating
		 */
		_initTemplating : function() {
			var that = this, templateInitDfd = $.Deferred();

			// Helper to get first component of given type
			Handlebars.registerHelper(&#x27;toClass&#x27;, function(str) {
				return UTIL.toClass(str);
			});

			// Helper to get first component of given type
			Handlebars.registerHelper(&#x27;tScaleWrap&#x27;, function(str) {
				str = Handlebars.Utils.escapeExpression(str);// escape
				return new Handlebars.SafeString(&quot;&lt;span class=&#x27;&quot; + CONS.CSS_CLASSES.textScale
						+ &quot;&#x27; style=&#x27;position:static&#x27;&gt;&quot; + str + &quot;&lt;/span&gt;&quot;);// mark
				// as
				// encoded
			});

			// Helper to get first component of given type
			Handlebars.registerHelper(&#x27;firstComp&#x27;, function(context, type, options) {
				var out = &#x27;&#x27;;
				if (context.hasComponentType(type)) {
					out += options.fn(context.components[type][0]);
				}
				return out;
			});

			// Helper to get first component of given type
			Handlebars.registerHelper(&#x27;hasCompType&#x27;, function(context, type, options) {
				if (context.hasComponentType(type)) {
					return options.fn(this);
				}
			});

			// Helper to get each component of given type
			Handlebars.registerHelper(&#x27;compsEach&#x27;, function(context, type, options) {
				var out = &#x27;&#x27;;
				context.forEachComponentType(type, function(component) {
					out += options.fn(component);
				});
				return out;
			});

			// Helper to iterate over keys of given context
			Handlebars.registerHelper(&#x27;keysEach&#x27;, function(context, options) {
				var out = &#x27;&#x27;;
				for ( var key in context) {
					out += options.fn(key);
				}
				return out;
			});

			// Helper to check if language of given context is undefined or &quot;en&quot;
			Handlebars.registerHelper(&#x27;ifLang&#x27;, function(context, options) {
				if (context &amp;&amp; (context.lang === undefined || context.lang === &quot;en&quot;)) {
					return options.fn(this);
				}
			});

			Handlebars.registerHelper(&#x27;predicateLabelRetriver&#x27;, function(ctx, options) {
				if (ctx &amp;&amp; !ctx.label) {
					var uriArray = ctx.value.split(&quot;#&quot;);
					if (uriArray.length === 1) {
						uriArray = uriArray[0].split(&quot;/&quot;);
					}
					ctx.label = uriArray[uriArray.length - 1];
				}
				return options.fn(this);
			});

			var loader = new Plugin.TemplatesLoader(templateInitDfd);
			loader.getPrecompiledTemplates();
			return templateInitDfd.promise();
		},
		/**
		 * Generate the queries of the Plugin
		 * 
		 * @private
		 * @method _generateQueries
		 */
		_generateQueries : function() {
			var that = this;

			// Generate SPARQL queries
			queryStore = {
				defaultInitRemoteQuery : this.options.layerOptions.remoteOptions.defaultInitRemoteQuery,
				remoteResByLabel : &quot;SELECT DISTINCT ?subject ?predicate ?object WHERE { VALUES ?predicate {rdfs:label} VALUES ?object {&#x27;&quot;
						+ CONS.DUMMY + &quot;&#x27;@&quot; + that.options.language + &quot;} ?subject ?predicate ?object}&quot;,
				remoteSubjectOf : &quot; SELECT DISTINCT ?subject ?predicate ?object ?labelObj ?labelPred WHERE { VALUES ?subject {&lt;&quot;
						+ CONS.DUMMY
						+ &quot;&gt;} ?subject ?predicate ?object. OPTIONAL { ?object rdfs:label ?labelObj }. OPTIONAL { ?predicate rdfs:label ?labelPred }. FILTER(isIRI(?object)  || (LANG(?object) = &#x27;&#x27; || LANGMATCHES(LANG(?object), &#x27;&quot;
						+ that.options.language
						+ &quot;&#x27;))). FILTER(LANG(?labelPred) = &#x27;&#x27; || LANGMATCHES(LANG(?labelPred), &#x27;&quot;
						+ that.options.language
						+ &quot;&#x27;)). FILTER(LANG(?labelObj) = &#x27;&#x27; || LANGMATCHES(LANG(?labelObj), &#x27;&quot;
						+ that.options.language + &quot;&#x27;))}&quot;,
				remoteObjectOf : &quot; SELECT DISTINCT ?subject ?predicate ?object ?labelSub ?labelPred WHERE {VALUES ?object {&lt;&quot;
						+ CONS.DUMMY
						+ &quot;&gt;} ?subject ?predicate ?object. OPTIONAL { ?subject rdfs:label ?labelSub }. OPTIONAL { ?predicate rdfs:label ?labelPred }. FILTER(isIRI(?subject)  || (LANG(?subject) = &#x27;&#x27; || LANGMATCHES(LANG(?subject), &#x27;&quot;
						+ that.options.language
						+ &quot;&#x27;))). FILTER(LANG(?labelPred) = &#x27;&#x27; || LANGMATCHES(LANG(?labelPred), &#x27;&quot;
						+ that.options.language
						+ &quot;&#x27;)). FILTER(LANG(?labelSub) = &#x27;&#x27; || LANGMATCHES(LANG(?labelSub), &#x27;&quot;
						+ that.options.language + &quot;&#x27;))}&quot;,
				remoteLiteralIsObjectOf : &quot; SELECT DISTINCT ?subject ?predicate ?object ?labelSub ?labelPred WHERE {VALUES ?object {&#x27;&quot;
						+ CONS.DUMMY
						+ &quot;&#x27;} ?subject ?predicate ?object. OPTIONAL { ?subject rdfs:label ?labelSub }. OPTIONAL { ?predicate rdfs:label ?labelPred }}&quot;,
				selectSubjectOf : &quot; SELECT DISTINCT ?subject ?predicate ?label ?description WHERE {&lt;&quot;
						+ CONS.DUMMY
						+ &quot;&gt; ?predicate ?subject. OPTIONAL { ?subject rdfs:label ?label}. OPTIONAL { ?subject rdfs:description ?description } . OPTIONAL { ?subject rdfs:comment ?description }}&quot;,
				selectObjectOf : &quot; SELECT DISTINCT ?subject ?predicate ?label ?description WHERE {?subject ?predicate &lt;&quot;
						+ CONS.DUMMY
						+ &quot;&gt;. OPTIONAL { ?subject rdfs:label ?label}. OPTIONAL { ?subject rdfs:description ?description } . OPTIONAL { ?subject rdfs:comment ?description }}&quot;,
				typeQuery : &quot;SELECT DISTINCT ?type WHERE {&lt;&quot; + CONS.DUMMY + &quot;&gt; a ?type} ORDER BY ?type&quot;,
				labelIsObjectOf : &quot;SELECT DISTINCT ?subject ?label WHERE { ?subject &lt;&quot; + namespaces.rdfs + &quot;label&gt; ?label. FILTER (STR(?label)=&#x27;&quot;
					+ CONS.DUMMY
					+ &quot;&#x27;)}&quot;,
				literalIsObjectOf : &quot;SELECT DISTINCT ?subject ?predicate ?type ?label ?description WHERE {?subject ?predicate ?oLiteral. FILTER (STR(?oLiteral)=&#x27;&quot;
						+ CONS.DUMMY
						+ &quot;&#x27;). OPTIONAL { ?subject rdfs:label ?label}. OPTIONAL { ?subject rdfs:description ?description } . OPTIONAL { ?subject rdfs:comment ?description }}&quot;,
				previewQuery : &quot; SELECT DISTINCT ?label ?description ?type WHERE { &lt;&quot; + CONS.DUMMY
						+ &quot;&gt; rdfs:label ?label . OPTIONAL { &lt;&quot; + CONS.DUMMY
						+ &quot;&gt; rdfs:description ?description } . OPTIONAL { &lt;&quot; + CONS.DUMMY
						+ &quot;&gt; rdfs:comment ?description } . OPTIONAL { &lt;&quot; + CONS.DUMMY + &quot;&gt; rdfs:type ?type}}&quot;,
				label : &quot;SELECT DISTINCT ?label WHERE { &lt;&quot; + CONS.DUMMY
						+ &quot;&gt; rdfs:label ?label . FILTER(LANG(?label) = &#x27;&#x27; || LANGMATCHES(LANG(?label), &#x27;&quot;
						+ that.options.language + &quot;&#x27;))}&quot;,
				blankNodeQuery : &quot;SELECT DISTINCT ?object WHERE {&lt;&quot; + CONS.DUMMY + &quot;&gt; ?predicate ?object}&quot;
			};
		},
		/**
		 * Check whether the plugin is initialized with insertion options and call
		 * insertion methods if needed.
		 * 
		 * @private
		 * @method _checkInsertion
		 * @returns {Boolean} true if data was inserted, false if not
		 */
		_checkInsertion : function() {
			var that = this, inserted = false;
			if (!isUndefinedOrNull(that.options.dataFormat)) {
				if (!isUndefinedOrNull(that.options.dataLoc)) {
					inserted = true;
					that._ajaxLoadData(that.options.dataLoc, that.options.dataFormat,
							function(rdfData, dataFormat) {
								rdfStore.insertData(rdfData, dataFormat, function() {
									eventManagers[that.pluginID].trigger(CONS.EVENT_TYPES.store.insert, that);
								});
							});
				} else if (!isUndefinedOrNull(that.options.data)) {
					inserted = true;
					rdfStore.insertData(that.options.data, that.options.dataFormat, function() {
						eventManagers[that.pluginID].trigger(CONS.EVENT_TYPES.store.insert, that);
					});
				}
			}
			return inserted;
		},
		/**
		 * Loads file at dataURL and invokes callback with loaded data
		 * 
		 * @private
		 * @method _ajaxLoadData
		 * @param {String}
		 *           dataURL URL where the data is located
		 * @param {String}
		 *           dataFormat Format of the data
		 * @param {String}
		 *           callback Function to call after loading with results
		 * @return function with modified context
		 */
		_ajaxLoadData : function(dataURL, dataFormat, callback) {
			var that = this;
			eventManagers[that.pluginID].trigger(CONS.EVENT_TYPES.loading.start, that);

			// print(&quot;_ajaxLoadData&quot;);
			$.ajax({
				url : dataURL,
				dataType : &quot;text&quot;,
				success : function(rdfData) {
					callback(rdfData, dataFormat);
				}
			}).fail(function() {
				eventManagers[that.pluginID].trigger(CONS.EVENT_TYPES.loading.done, that);
				alert(CONS.MESSAGES.error.ajax);
			});
		},
		// &lt;!--- instance private functions ----&gt;

		/**
		 * Init the plugin. Called by the constructor.
		 * 
		 * @method init
		 */
		init : function() {
			var that = this;

			// Generate SPARQL Queries
			that._generateQueries();
			that._initRemoteDataLoader();

			// Add insertion listener
			eventManagers[this.pluginID].addEventHandler(CONS.EVENT_TYPES.store.insert, function(ev) {
				// TODO update on insertion
				$.each(that._layers, function(key, layer) {
					// layer.update();
					print(&quot;view &quot; + key + &quot; has to be updated updating&quot;);
				});
			});

			// Add a smartresize listener (smartresize to be found in
			// jQuery.isotope)
			eventManagers[this.pluginID].addEventHandler(&#x27;throttledresize&#x27;, function(ev, $invoker) {

				// &lt;---- overlay modification ----&gt;
				var $overlays = that._$parent.children(UTIL.toSelector(CONS.CSS_CLASSES.overlay));
				$overlays.css(&#x27;clip&#x27;, getClip(CONS.CSS_CLASSES.overlay));
				var innerScrolls = $overlays.find(UTIL.toSelector(CONS.CSS_CLASSES.innerScroll));
				innerScrolls.css(&quot;width&quot;,
						($window.width() - parseInt($overlays.css(&quot;padding-left&quot;)) - parseInt($overlays
								.css(&quot;padding-right&quot;)))
								+ &quot;px&quot;);
				innerScrolls.css(&quot;height&quot;, $window.height()
						- $overlays.find(UTIL.toSelector(CONS.CSS_CLASSES.innerNoScroll)).height() + &quot;px&quot;);
				// &lt;!--- overlay modification ----&gt;
			}, $window);

			if (that.options.generateTimeline) {
				this.timeLine = new Plugin.TimeLine(this._$parent);
			}

			// Init templating and RdfStore if needed
			if (globalInitDfd.state() === &quot;pending&quot;) {
				globalInitDfd = $.Deferred();
				$.when(that._initRdfStore(), that._initTemplating()).done(function() {

					// Load runtime templates
					var tmp_templates = {};
					$.each(that.options.layerOptions.nodeFilters, function(i, filter) {
						if (filter.template) {
							if (templates[i]) {
								console.log(&quot;Template with identifier &quot; + i + &quot; already defined&quot;);
							} else {
								tmp_templates[i] = Handlebars.compile(filter.template);
							}
						}
					});

					$.extend(true, templates, tmp_templates);
					globalInitDfd.resolve();
				});
			}

			// when done check if sort options have to be initialized and data
			// is to be inserted
			$.when(globalInitDfd.promise()).done(
					function() {

						// Init Layer
						that._layers = {};
						var args = [];
						args.push(that._$parent);
						args.push(that.options.layerOptions);
						// prepend parent and options to arg array
						args = args.concat(that.options.initLayer.args);
						// call constructor with apply args
						var layer = construct(Plugin.Layers[that.options.initLayer.name], args);
						that.addLayer(layer);
						that._topLayer = layer.id;
						that._layers[layer.id].initSwitch.attach(new Plugin.Listener(function(sender) {

							// Open detail on init
							if (that.options.openDetailOnInit != &quot;&quot;) {
								layer.view.layoutEngine.doneEvent.once(new Plugin.Listener(function(sender) {
									setTimeout(function() {
										layer.view.layoutEngine._container.find(
												&quot;div:contains(&quot; + that.options.openDetailOnInit + &quot;)&quot;).click();
									}, 200);
								}));
							}
							// Insert data
							if (!that._checkInsertion()) {
								if (that.options.sparqlData === undefined) {
									layer.update();
								} else {
									remoteDataLoader.insertByResultset(that.options.sparqlData, function() {
										layer.update();
									});
								}
							}
						}));
					});
		},
		/**
		 * Add given Layer object to the plugin
		 * 
		 * @method addLayer
		 * @param {Plugin.Layer}
		 *           layer Layer object to add to the plugin
		 */
		addLayer : function(layer) {
			var that = this;
			this._layers[layer.id] = layer;

			// Add listener for timeLine opening
			var listener = new Plugin.Listener(function(sender) {
				if (that.timeLine) {
					that.timeLine.addLayer(sender);
					sender.getTimeLineButton().on(&quot;click&quot;, function() {
						that.timeLine.open();
					});
				}
			});
			layer.initSwitch.attach(listener);
			layer.openEvent.attach(new Plugin.Listener(function(sender) {
				that._topLayer = sender.id;
				that._extendedLayers[sender.id] = sender.zIndex;
				that.$body.addClass(&#x27;noscroll&#x27;);
			}));
			layer.closeEvent.attach(new Plugin.Listener(function(sender) {
				delete that._extendedLayers[sender.id];
				if ($.isEmptyObject(that._extendedLayers)) {
					that.$body.removeClass(&#x27;noscroll&#x27;);
					var tmp = 0;
					$.each(that._extendedLayers, function(layerID, zIndex) {
						if (tmp &lt; zIndex) {
							tmp = zIndex;
							that._topLayer = layerID;
						}
					});
				} else {
					delete that._topLayer;
				}
			}));
			layer.filterEvent.attach(new Plugin.Listener(function(sender, args) {
				switch (args.action) {
				case &quot;addLayer&quot;:
					that.addLayer(args.args);
					break;
				case &quot;removeLayer&quot;:
					that.removeLayer(sender);
					break;
				}
			}));
			layer.open();
		},

		/**
		 * Remove given Layer object from the plugin
		 * 
		 * @method removeLayer
		 * @param {Plugin.Layer}
		 *           view Layer object to remove from the plugin
		 */
		removeLayer : function(layer) {
			delete this._layers[layer.id];
		},

		/**
		 * Update all layers of the plugin
		 * 
		 * @method updateLayers
		 */
		updateTopLayer : function() {
			if (this._topLayer) {
				this._layers[this._topLayer].update();
			}
		},
		/**
		 * Insert given rdf-data in the store.
		 * 
		 * @method insertData
		 * @param {String}
		 *           data Rdf-data to be inserted
		 * @param {String}
		 *           dataFormat Format of the data
		 */
		insertData : function(data, dataFormat) {
			var that = this;
			$.when(globalInitDfd.promise()).done(function() {
				rdfStore.insertData(data, dataFormat, function() {
					eventManagers[that.pluginID].trigger(CONS.EVENT_TYPES.store.insert, that);
					that.updateTopLayer();
				});
			});
		},
		/**
		 * Insert rdf-data of given location in the store. Consider cross domain
		 * restrictions when using this method.
		 * 
		 * @method insertDataPath
		 * @param {String}
		 *           dataURL URL where rdf data is to be found
		 * @param {String}
		 *           dataFormat Format of the data
		 */
		insertDataPath : function(dataURL, dataFormat) {
			var that = this;
			$.when(globalInitDfd.promise()).done(function() {
				that._ajaxLoadData(dataURL, dataFormat, that._selfProxy(that.insertData));
			});
		},
		/**
		 * Insert rdf-data of given file in the store.
		 * 
		 * @method insertDataFile
		 * @param {File}
		 *           file File to parse
		 * @param {String}
		 *           dataFormat Format of the data
		 */
		insertDataFile : function(file) {
			var that = this, reader = new FileReader();
			reader.onload = function() {
				var result = this.result;
				var type = &quot;text/turtle&quot;;
				if (file.type === &quot;&quot;) {
					var extension = file.name.split(&quot;.&quot;).pop();
					switch (extension) {
					case &quot;ttl&quot;:
						type = &quot;text/turtle&quot;;
						break;
					case &quot;turtle&quot;:
						type = &quot;text/turtle&quot;;
						break;
					case &quot;n3&quot;:
						type = &quot;text/n3&quot;;
						break;
					case &quot;json&quot;:
						type = &quot;application/json&quot;;
						break;
					case &quot;jsld&quot;:
						type = &quot;application/ld+json&quot;;
						break;
					default:
						console.log(CONS.MESSAGES.warn.fileTypeNotKnown + type);
					}
				} else {
					type = file.type;
				}
				$.when(globalInitDfd.promise()).done(function() {
					that.insertData(result, type);
				});
			};
			reader.readAsText(file);
		},
		insertRemoteByLabel : function(str) {
			$.when(globalInitDfd.promise()).done(function() {
				var query = replaceDummy(queryStore.remoteResByLabel, str);
				remoteDataLoader.insertByQuery(query);
			});
		},
		openViewByLabel : function(str) {
			var that = this;
			var fail = function() {
				alert(&quot;Didn&#x27;t find an entry for &quot; + str + &quot;.&quot;);
			};
			var openLayer = function(data) {
				var node = new Plugin.Nodes.Res(data);
				var tile = node.generateTile();
				// TODO no layer given hack
				// TODO Backgroundcolor event?
				tile.css({ &quot;background-color&quot; : &quot;#444444&quot;});
				var tileWrapped = that.options.layerOptions.tileFilters.backgroundColor.fn({
					0 : tile
				}, that.options.layerOptions.tileFilters.backgroundColor.config, this._topLayer);
				remoteDataLoader.loadingDone.once(new Plugin.Listener(function() {
					var layer = new Plugin.Layers.Res(that._$parent, that.options.layerOptions, tileWrapped[0]);
					that.addLayer(layer);
				}));
			};
			var query = replaceDummy(queryStore.labelIsObjectOf, str);
			rdfStore.executeQuery(
							query,
							function(results) {
								if (results &amp;&amp; results.length &gt; 0) {
									if (results.length === 1) {
										openLayer(results[0]);
									} else {
										var div = $(&quot;&lt;div style=&#x27;height: auto; width: auto; margin-right: auto; margin-left: auto; max-width: 500px; background-color: #111111&#x27;&gt; What item should be viewed?&lt;ul&gt;&lt;/ul&gt;&lt;/div&gt;&quot;);
										var ul = div.find(&quot;ul&quot;);
										for (var i = 0; i &lt; results.length; i++) {
											var data = results[i];
											var li = $(&quot;&lt;li&gt;&lt;a&gt;&quot; + data.subject.value + &quot;&lt;/a&gt;&lt;/li&gt;&quot;);
											li.click(function(data) {
												return function(e) {
													openLayer(data);
													$.magnificPopup.close();
												}
											}(data));
											ul.append(li);
										}
										$.magnificPopup.open({
											items : {
												src : div,
												type : &#x27;inline&#x27;
											}
										});
									}
								} else {
									fail();
								}
							}, fail);
		},
		insertRemoteAndOpenViewByLabel : function(str) {
			var that = this;
			that.insertRemoteByLabel(str);
			remoteDataLoader.loadingDone.once(new Plugin.Listener(function() {
				that.openViewByLabel(str);
			}));
		},
		/**
		 * Insert rdf-data of given url SPARQL service in the store. Use the given
		 * query. Is no query given use the default query.
		 * 
		 * @method insertRemoteDataQuery
		 * @param {String}
		 *           url URL of the SPARQL service
		 * @param {String}
		 *           query Query to fetch data
		 */
		insertRemoteDataQuery : function(url, query) {
			var that = this;
			$.when(globalInitDfd.promise()).done(function() {
				if (query === undefined || query === &quot;&quot;) {
					query = queryStore.defaultInitRemoteQuery;
				}
				remoteDataLoader.insertByQuery(query, [ url ]);
				remoteDataLoader.loadingDone.once(new Plugin.Listener(function() {
					that.updateTopLayer();
				}));
			});
		},
		/**
		 * Clear the store and Layers.
		 * 
		 * @method clearStore
		 */
		clearStore : function() {
			var that = this;
			rdfStore.executeQuery(&quot;CLEAR ALL&quot;, function() {
				print(&quot;store cleared&quot;);
				$.each(that._layers, function(i, view) {
					view.removeAllItems();
				});
			});
		},
		/**
		 * Runs query on local store.
		 * 
		 * @method runQuery
		 * @param query
		 *           Query to run.
		 * @return results of query
		 */
		runQuery : function(query, callback) {
			rdfStore.executeQuery(query, function(results) {
				if (callback) {
					callback(results);
				}
			});
		},
		/**
		 * Clean up after plugin (destroy bindings, clear events..)
		 * 
		 * @method destroy
		 */
		destroy : function() {
			var that = this;
			eventManagers[that.pluginID].destory();
			eventManagers[that.pluginID] = undefined;
			that._$parent[pluginName] = null;
		}
	};

	// Lightweight plugin frame.
	$.fn[pluginName] = function(options) {
		return this.each(function() {
			if (!$.data(this, &quot;plugin_&quot; + pluginName)) {
				$.data(this, &quot;plugin_&quot; + pluginName, new Plugin(this, options));
			}
		});
	};

})(jQuery, window, document);

// Copyright 2013 Thomas Weissgerber
//	
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//	
// http://www.apache.org/licenses/LICENSE-2.0
//	
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
